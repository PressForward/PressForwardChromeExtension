window.pfSiteData = {}; window.pfSiteData.site_url = "https://local.wordpress.test"; window.pfSiteData.plugin_url = "https://local.wordpress.test/wp-content/plugins/pressforward/"; window.pfSiteData.submit_endpoint = "https://local.wordpress.test/wp-json\/pf/v1/submit-nomination"; window.pfSiteData.fontFace = "@font-face { font-family: 'tinymce'; src: url(data:application/font-woff2;charset=utf-8;base64,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) format('woff2'), url(data:application/font-woff;charset=utf-8;base64,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) format('woff'); font-weight: normal; font-style: normal; } @font-face { font-family: 'tinymce'; src: url(data:application/font-woff2;charset=utf-8;base64,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) format('woff2'), url(data:application/font-woff;charset=utf-8;base64,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) format('woff'); font-weight: normal; font-style: normal; }"// From: https://github.com/kjur/jsrsasign/blob/master/src/jws-3.3.js
window.pfSiteData.categories_endpoint = 'https://local.wordpress.test/wp-json/wp/v2/categories';
/* Pell */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.pell = {}) }(this, function (t) { "use strict"; var e = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, n = function (t, e, n) { return t.addEventListener(e, n) }, r = function (t, e) { return t.appendChild(e) }, i = function (t) { return document.createElement(t) }, o = function (t) { return document.queryCommandState(t) }, u = function (t) { return document.queryCommandValue(t) }, c = function (t) { var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null; return document.execCommand(t, !1, e) }, l = { bold: { icon: "<b>B</b>", title: "Bold", state: function () { return o("bold") }, result: function () { return c("bold") } }, italic: { icon: "<i>I</i>", title: "Italic", state: function () { return o("italic") }, result: function () { return c("italic") } }, underline: { icon: "<u>U</u>", title: "Underline", state: function () { return o("underline") }, result: function () { return c("underline") } }, strikethrough: { icon: "<strike>S</strike>", title: "Strike-through", state: function () { return o("strikeThrough") }, result: function () { return c("strikeThrough") } }, heading1: { icon: "<b>H<sub>1</sub></b>", title: "Heading 1", result: function () { return c("formatBlock", "<h1>") } }, heading2: { icon: "<b>H<sub>2</sub></b>", title: "Heading 2", result: function () { return c("formatBlock", "<h2>") } }, paragraph: { icon: "&#182;", title: "Paragraph", result: function () { return c("formatBlock", "<p>") } }, quote: { icon: "&#8220; &#8221;", title: "Quote", result: function () { return c("formatBlock", "<blockquote>") } }, olist: { icon: "&#35;", title: "Ordered List", result: function () { return c("insertOrderedList") } }, ulist: { icon: "&#8226;", title: "Unordered List", result: function () { return c("insertUnorderedList") } }, code: { icon: "&lt;/&gt;", title: "Code", result: function () { return c("formatBlock", "<pre>") } }, line: { icon: "&#8213;", title: "Horizontal Line", result: function () { return c("insertHorizontalRule") } }, link: { icon: "&#128279;", title: "Link", result: function () { var t = window.prompt("Enter the link URL"); t && c("createLink", t) } }, image: { icon: "&#128247;", title: "Image", result: function () { var t = window.prompt("Enter the image URL"); t && c("insertImage", t) } } }, a = { actionbar: "pell-actionbar", button: "pell-button", content: "pell-content", selected: "pell-button-selected" }, s = function (t) { var o = t.actions ? t.actions.map(function (t) { return "string" == typeof t ? l[t] : l[t.name] ? e({}, l[t.name], t) : t }) : Object.keys(l).map(function (t) { return l[t] }), s = e({}, a, t.classes), f = t.defaultParagraphSeparator || "div", d = i("div"); d.className = s.actionbar, r(t.element, d); var m = t.element.content = i("div"); return m.contentEditable = !0, m.className = s.content, m.oninput = function (e) { var n = e.target.firstChild; n && 3 === n.nodeType ? c("formatBlock", "<" + f + ">") : "<br>" === m.innerHTML && (m.innerHTML = ""), t.onChange(m.innerHTML) }, m.onkeydown = function (t) { "Tab" === t.key ? t.preventDefault() : "Enter" === t.key && "blockquote" === u("formatBlock") && setTimeout(function () { return c("formatBlock", "<" + f + ">") }, 0) }, r(t.element, m), o.forEach(function (t) { var e = i("button"); if (e.className = s.button, e.innerHTML = t.icon, e.title = t.title, e.setAttribute("type", "button"), e.onclick = function () { return t.result() && m.focus() }, t.state) { var o = function () { return e.classList[t.state() ? "add" : "remove"](s.selected) }; n(m, "keyup", o), n(m, "mouseup", o), n(e, "click", o) } r(d, e) }), t.styleWithCSS && c("styleWithCSS"), c("defaultParagraphSeparator", f), t.element }, f = { exec: c, init: s }; t.exec = c, t.init = s, t.default = f, Object.defineProperty(t, "__esModule", { value: !0 }) });
/*
 * jsrsasign(jwths) 7.2.0 (2017-05-21) (c) 2010-2017 Kenji Urushima | kjur.github.com/jsrsasign/license
 */

/*
yahoo-min.js
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
if (typeof YAHOO == "undefined" || !YAHOO) { var YAHOO = {}; } YAHOO.namespace = function () { var b = arguments, g = null, e, c, f; for (e = 0; e < b.length; e = e + 1) { f = ("" + b[e]).split("."); g = YAHOO; for (c = (f[0] == "YAHOO") ? 1 : 0; c < f.length; c = c + 1) { g[f[c]] = g[f[c]] || {}; g = g[f[c]]; } } return g; }; YAHOO.log = function (d, a, c) { var b = YAHOO.widget.Logger; if (b && b.log) { return b.log(d, a, c); } else { return false; } }; YAHOO.register = function (a, f, e) { var k = YAHOO.env.modules, c, j, h, g, d; if (!k[a]) { k[a] = { versions: [], builds: [] }; } c = k[a]; j = e.version; h = e.build; g = YAHOO.env.listeners; c.name = a; c.version = j; c.build = h; c.versions.push(j); c.builds.push(h); c.mainClass = f; for (d = 0; d < g.length; d = d + 1) { g[d](c); } if (f) { f.VERSION = j; f.BUILD = h; } else { YAHOO.log("mainClass is undefined for module " + a, "warn"); } }; YAHOO.env = YAHOO.env || { modules: [], listeners: [] }; YAHOO.env.getVersion = function (a) { return YAHOO.env.modules[a] || null; }; YAHOO.env.parseUA = function (d) { var e = function (i) { var j = 0; return parseFloat(i.replace(/\./g, function () { return (j++ == 1) ? "" : "."; })); }, h = navigator, g = { ie: 0, opera: 0, gecko: 0, webkit: 0, chrome: 0, mobile: null, air: 0, ipad: 0, iphone: 0, ipod: 0, ios: null, android: 0, webos: 0, caja: h && h.cajaVersion, secure: false, os: null }, c = d || (navigator && navigator.userAgent), f = window && window.location, b = f && f.href, a; g.secure = b && (b.toLowerCase().indexOf("https") === 0); if (c) { if ((/windows|win32/i).test(c)) { g.os = "windows"; } else { if ((/macintosh/i).test(c)) { g.os = "macintosh"; } else { if ((/rhino/i).test(c)) { g.os = "rhino"; } } } if ((/KHTML/).test(c)) { g.webkit = 1; } a = c.match(/AppleWebKit\/([^\s]*)/); if (a && a[1]) { g.webkit = e(a[1]); if (/ Mobile\//.test(c)) { g.mobile = "Apple"; a = c.match(/OS ([^\s]*)/); if (a && a[1]) { a = e(a[1].replace("_", ".")); } g.ios = a; g.ipad = g.ipod = g.iphone = 0; a = c.match(/iPad|iPod|iPhone/); if (a && a[0]) { g[a[0].toLowerCase()] = g.ios; } } else { a = c.match(/NokiaN[^\/]*|Android \d\.\d|webOS\/\d\.\d/); if (a) { g.mobile = a[0]; } if (/webOS/.test(c)) { g.mobile = "WebOS"; a = c.match(/webOS\/([^\s]*);/); if (a && a[1]) { g.webos = e(a[1]); } } if (/ Android/.test(c)) { g.mobile = "Android"; a = c.match(/Android ([^\s]*);/); if (a && a[1]) { g.android = e(a[1]); } } } a = c.match(/Chrome\/([^\s]*)/); if (a && a[1]) { g.chrome = e(a[1]); } else { a = c.match(/AdobeAIR\/([^\s]*)/); if (a) { g.air = a[0]; } } } if (!g.webkit) { a = c.match(/Opera[\s\/]([^\s]*)/); if (a && a[1]) { g.opera = e(a[1]); a = c.match(/Version\/([^\s]*)/); if (a && a[1]) { g.opera = e(a[1]); } a = c.match(/Opera Mini[^;]*/); if (a) { g.mobile = a[0]; } } else { a = c.match(/MSIE\s([^;]*)/); if (a && a[1]) { g.ie = e(a[1]); } else { a = c.match(/Gecko\/([^\s]*)/); if (a) { g.gecko = 1; a = c.match(/rv:([^\s\)]*)/); if (a && a[1]) { g.gecko = e(a[1]); } } } } } } return g; }; YAHOO.env.ua = YAHOO.env.parseUA(); (function () { YAHOO.namespace("util", "widget", "example"); if ("undefined" !== typeof YAHOO_config) { var b = YAHOO_config.listener, a = YAHOO.env.listeners, d = true, c; if (b) { for (c = 0; c < a.length; c++) { if (a[c] == b) { d = false; break; } } if (d) { a.push(b); } } } })(); YAHOO.lang = YAHOO.lang || {}; (function () {
	var f = YAHOO.lang, a = Object.prototype, c = "[object Array]", h = "[object Function]", i = "[object Object]", b = [], g = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#x27;", "/": "&#x2F;", "`": "&#x60;" }, d = ["toString", "valueOf"], e = {
		isArray: function (j) { return a.toString.apply(j) === c; }, isBoolean: function (j) { return typeof j === "boolean"; }, isFunction: function (j) { return (typeof j === "function") || a.toString.apply(j) === h; }, isNull: function (j) { return j === null; }, isNumber: function (j) { return typeof j === "number" && isFinite(j); }, isObject: function (j) { return (j && (typeof j === "object" || f.isFunction(j))) || false; }, isString: function (j) { return typeof j === "string"; }, isUndefined: function (j) { return typeof j === "undefined"; }, _IEEnumFix: (YAHOO.env.ua.ie) ? function (l, k) { var j, n, m; for (j = 0; j < d.length; j = j + 1) { n = d[j]; m = k[n]; if (f.isFunction(m) && m != a[n]) { l[n] = m; } } } : function () { }, escapeHTML: function (j) { return j.replace(/[&<>"'\/`]/g, function (k) { return g[k]; }); }, extend: function (m, n, l) { if (!n || !m) { throw new Error("extend failed, please check that " + "all dependencies are included."); } var k = function () { }, j; k.prototype = n.prototype; m.prototype = new k(); m.prototype.constructor = m; m.superclass = n.prototype; if (n.prototype.constructor == a.constructor) { n.prototype.constructor = n; } if (l) { for (j in l) { if (f.hasOwnProperty(l, j)) { m.prototype[j] = l[j]; } } f._IEEnumFix(m.prototype, l); } }, augmentObject: function (n, m) { if (!m || !n) { throw new Error("Absorb failed, verify dependencies."); } var j = arguments, l, o, k = j[2]; if (k && k !== true) { for (l = 2; l < j.length; l = l + 1) { n[j[l]] = m[j[l]]; } } else { for (o in m) { if (k || !(o in n)) { n[o] = m[o]; } } f._IEEnumFix(n, m); } return n; }, augmentProto: function (m, l) { if (!l || !m) { throw new Error("Augment failed, verify dependencies."); } var j = [m.prototype, l.prototype], k; for (k = 2; k < arguments.length; k = k + 1) { j.push(arguments[k]); } f.augmentObject.apply(this, j); return m; }, dump: function (j, p) { var l, n, r = [], t = "{...}", k = "f(){...}", q = ", ", m = " => "; if (!f.isObject(j)) { return j + ""; } else { if (j instanceof Date || ("nodeType" in j && "tagName" in j)) { return j; } else { if (f.isFunction(j)) { return k; } } } p = (f.isNumber(p)) ? p : 3; if (f.isArray(j)) { r.push("["); for (l = 0, n = j.length; l < n; l = l + 1) { if (f.isObject(j[l])) { r.push((p > 0) ? f.dump(j[l], p - 1) : t); } else { r.push(j[l]); } r.push(q); } if (r.length > 1) { r.pop(); } r.push("]"); } else { r.push("{"); for (l in j) { if (f.hasOwnProperty(j, l)) { r.push(l + m); if (f.isObject(j[l])) { r.push((p > 0) ? f.dump(j[l], p - 1) : t); } else { r.push(j[l]); } r.push(q); } } if (r.length > 1) { r.pop(); } r.push("}"); } return r.join(""); }, substitute: function (x, y, E, l) { var D, C, B, G, t, u, F = [], p, z = x.length, A = "dump", r = " ", q = "{", m = "}", n, w; for (; ;) { D = x.lastIndexOf(q, z); if (D < 0) { break; } C = x.indexOf(m, D); if (D + 1 > C) { break; } p = x.substring(D + 1, C); G = p; u = null; B = G.indexOf(r); if (B > -1) { u = G.substring(B + 1); G = G.substring(0, B); } t = y[G]; if (E) { t = E(G, t, u); } if (f.isObject(t)) { if (f.isArray(t)) { t = f.dump(t, parseInt(u, 10)); } else { u = u || ""; n = u.indexOf(A); if (n > -1) { u = u.substring(4); } w = t.toString(); if (w === i || n > -1) { t = f.dump(t, parseInt(u, 10)); } else { t = w; } } } else { if (!f.isString(t) && !f.isNumber(t)) { t = "~-" + F.length + "-~"; F[F.length] = p; } } x = x.substring(0, D) + t + x.substring(C + 1); if (l === false) { z = D - 1; } } for (D = F.length - 1; D >= 0; D = D - 1) { x = x.replace(new RegExp("~-" + D + "-~"), "{" + F[D] + "}", "g"); } return x; }, trim: function (j) {
			try { return j.replace(/^\s+|\s+$/g, ""); } catch (k) {
				return j;
			}
		}, merge: function () { var n = {}, k = arguments, j = k.length, m; for (m = 0; m < j; m = m + 1) { f.augmentObject(n, k[m], true); } return n; }, later: function (t, k, u, n, p) { t = t || 0; k = k || {}; var l = u, s = n, q, j; if (f.isString(u)) { l = k[u]; } if (!l) { throw new TypeError("method undefined"); } if (!f.isUndefined(n) && !f.isArray(s)) { s = [n]; } q = function () { l.apply(k, s || b); }; j = (p) ? setInterval(q, t) : setTimeout(q, t); return { interval: p, cancel: function () { if (this.interval) { clearInterval(j); } else { clearTimeout(j); } } }; }, isValue: function (j) { return (f.isObject(j) || f.isString(j) || f.isNumber(j) || f.isBoolean(j)); }
	}; f.hasOwnProperty = (a.hasOwnProperty) ? function (j, k) { return j && j.hasOwnProperty && j.hasOwnProperty(k); } : function (j, k) { return !f.isUndefined(j[k]) && j.constructor.prototype[k] !== j[k]; }; e.augmentObject(f, e, true); YAHOO.util.Lang = f; f.augment = f.augmentProto; YAHOO.augment = f.augmentProto; YAHOO.extend = f.extend;
})(); YAHOO.register("yahoo", YAHOO, { version: "2.9.0", build: "2800" });

/*! CryptoJS v3.1.2 core-fix.js
 * code.google.com/p/crypto-js
 * (c) 2009-2013 by Jeff Mott. All rights reserved.
 * code.google.com/p/crypto-js/wiki/License
 * THIS IS FIX of 'core.js' to fix Hmac issue.
 * https://code.google.com/p/crypto-js/issues/detail?id=84
 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
 */
var CryptoJS = CryptoJS || (function (e, g) { var a = {}; var b = a.lib = {}; var j = b.Base = (function () { function n() { } return { extend: function (p) { n.prototype = this; var o = new n(); if (p) { o.mixIn(p) } if (!o.hasOwnProperty("init")) { o.init = function () { o.$super.init.apply(this, arguments) } } o.init.prototype = o; o.$super = this; return o }, create: function () { var o = this.extend(); o.init.apply(o, arguments); return o }, init: function () { }, mixIn: function (p) { for (var o in p) { if (p.hasOwnProperty(o)) { this[o] = p[o] } } if (p.hasOwnProperty("toString")) { this.toString = p.toString } }, clone: function () { return this.init.prototype.extend(this) } } }()); var l = b.WordArray = j.extend({ init: function (o, n) { o = this.words = o || []; if (n != g) { this.sigBytes = n } else { this.sigBytes = o.length * 4 } }, toString: function (n) { return (n || h).stringify(this) }, concat: function (t) { var q = this.words; var p = t.words; var n = this.sigBytes; var s = t.sigBytes; this.clamp(); if (n % 4) { for (var r = 0; r < s; r++) { var o = (p[r >>> 2] >>> (24 - (r % 4) * 8)) & 255; q[(n + r) >>> 2] |= o << (24 - ((n + r) % 4) * 8) } } else { for (var r = 0; r < s; r += 4) { q[(n + r) >>> 2] = p[r >>> 2] } } this.sigBytes += s; return this }, clamp: function () { var o = this.words; var n = this.sigBytes; o[n >>> 2] &= 4294967295 << (32 - (n % 4) * 8); o.length = e.ceil(n / 4) }, clone: function () { var n = j.clone.call(this); n.words = this.words.slice(0); return n }, random: function (p) { var o = []; for (var n = 0; n < p; n += 4) { o.push((e.random() * 4294967296) | 0) } return new l.init(o, p) } }); var m = a.enc = {}; var h = m.Hex = { stringify: function (p) { var r = p.words; var o = p.sigBytes; var q = []; for (var n = 0; n < o; n++) { var s = (r[n >>> 2] >>> (24 - (n % 4) * 8)) & 255; q.push((s >>> 4).toString(16)); q.push((s & 15).toString(16)) } return q.join("") }, parse: function (p) { var n = p.length; var q = []; for (var o = 0; o < n; o += 2) { q[o >>> 3] |= parseInt(p.substr(o, 2), 16) << (24 - (o % 8) * 4) } return new l.init(q, n / 2) } }; var d = m.Latin1 = { stringify: function (q) { var r = q.words; var p = q.sigBytes; var n = []; for (var o = 0; o < p; o++) { var s = (r[o >>> 2] >>> (24 - (o % 4) * 8)) & 255; n.push(String.fromCharCode(s)) } return n.join("") }, parse: function (p) { var n = p.length; var q = []; for (var o = 0; o < n; o++) { q[o >>> 2] |= (p.charCodeAt(o) & 255) << (24 - (o % 4) * 8) } return new l.init(q, n) } }; var c = m.Utf8 = { stringify: function (n) { try { return decodeURIComponent(escape(d.stringify(n))) } catch (o) { throw new Error("Malformed UTF-8 data") } }, parse: function (n) { return d.parse(unescape(encodeURIComponent(n))) } }; var i = b.BufferedBlockAlgorithm = j.extend({ reset: function () { this._data = new l.init(); this._nDataBytes = 0 }, _append: function (n) { if (typeof n == "string") { n = c.parse(n) } this._data.concat(n); this._nDataBytes += n.sigBytes }, _process: function (w) { var q = this._data; var x = q.words; var n = q.sigBytes; var t = this.blockSize; var v = t * 4; var u = n / v; if (w) { u = e.ceil(u) } else { u = e.max((u | 0) - this._minBufferSize, 0) } var s = u * t; var r = e.min(s * 4, n); if (s) { for (var p = 0; p < s; p += t) { this._doProcessBlock(x, p) } var o = x.splice(0, s); q.sigBytes -= r } return new l.init(o, r) }, clone: function () { var n = j.clone.call(this); n._data = this._data.clone(); return n }, _minBufferSize: 0 }); var f = b.Hasher = i.extend({ cfg: j.extend(), init: function (n) { this.cfg = this.cfg.extend(n); this.reset() }, reset: function () { i.reset.call(this); this._doReset() }, update: function (n) { this._append(n); this._process(); return this }, finalize: function (n) { if (n) { this._append(n) } var o = this._doFinalize(); return o }, blockSize: 512 / 32, _createHelper: function (n) { return function (p, o) { return new n.init(o).finalize(p) } }, _createHmacHelper: function (n) { return function (p, o) { return new k.HMAC.init(n, o).finalize(p) } } }); var k = a.algo = {}; return a }(Math));
/*
CryptoJS v3.1.2 x64-core-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (g) { var a = CryptoJS, f = a.lib, e = f.Base, h = f.WordArray, a = a.x64 = {}; a.Word = e.extend({ init: function (b, c) { this.high = b; this.low = c } }); a.WordArray = e.extend({ init: function (b, c) { b = this.words = b || []; this.sigBytes = c != g ? c : 8 * b.length }, toX32: function () { for (var b = this.words, c = b.length, a = [], d = 0; d < c; d++) { var e = b[d]; a.push(e.high); a.push(e.low) } return h.create(a, this.sigBytes) }, clone: function () { for (var b = e.clone.call(this), c = b.words = this.words.slice(0), a = c.length, d = 0; d < a; d++)c[d] = c[d].clone(); return b } }) })();

/*
CryptoJS v3.1.2 cipher-core.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
CryptoJS.lib.Cipher || function (u) {
	var g = CryptoJS, f = g.lib, k = f.Base, l = f.WordArray, q = f.BufferedBlockAlgorithm, r = g.enc.Base64, v = g.algo.EvpKDF, n = f.Cipher = q.extend({
		cfg: k.extend(), createEncryptor: function (a, b) { return this.create(this._ENC_XFORM_MODE, a, b) }, createDecryptor: function (a, b) { return this.create(this._DEC_XFORM_MODE, a, b) }, init: function (a, b, c) { this.cfg = this.cfg.extend(c); this._xformMode = a; this._key = b; this.reset() }, reset: function () { q.reset.call(this); this._doReset() }, process: function (a) {
			this._append(a);
			return this._process()
		}, finalize: function (a) { a && this._append(a); return this._doFinalize() }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function (a) { return { encrypt: function (b, c, d) { return ("string" == typeof c ? s : j).encrypt(a, b, c, d) }, decrypt: function (b, c, d) { return ("string" == typeof c ? s : j).decrypt(a, b, c, d) } } }
	}); f.StreamCipher = n.extend({ _doFinalize: function () { return this._process(!0) }, blockSize: 1 }); var m = g.mode = {}, t = function (a, b, c) {
		var d = this._iv; d ? this._iv = u : d = this._prevBlock; for (var e =
			0; e < c; e++)a[b + e] ^= d[e]
	}, h = (f.BlockCipherMode = k.extend({ createEncryptor: function (a, b) { return this.Encryptor.create(a, b) }, createDecryptor: function (a, b) { return this.Decryptor.create(a, b) }, init: function (a, b) { this._cipher = a; this._iv = b } })).extend(); h.Encryptor = h.extend({ processBlock: function (a, b) { var c = this._cipher, d = c.blockSize; t.call(this, a, b, d); c.encryptBlock(a, b); this._prevBlock = a.slice(b, b + d) } }); h.Decryptor = h.extend({
		processBlock: function (a, b) {
			var c = this._cipher, d = c.blockSize, e = a.slice(b, b + d); c.decryptBlock(a,
				b); t.call(this, a, b, d); this._prevBlock = e
		}
	}); m = m.CBC = h; h = (g.pad = {}).Pkcs7 = { pad: function (a, b) { for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, e = [], f = 0; f < c; f += 4)e.push(d); c = l.create(e, c); a.concat(c) }, unpad: function (a) { a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255 } }; f.BlockCipher = n.extend({
		cfg: n.cfg.extend({ mode: m, padding: h }), reset: function () {
			n.reset.call(this); var a = this.cfg, b = a.iv, a = a.mode; if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor; else c = a.createDecryptor, this._minBufferSize = 1;
			this._mode = c.call(a, this, b && b.words)
		}, _doProcessBlock: function (a, b) { this._mode.processBlock(a, b) }, _doFinalize: function () { var a = this.cfg.padding; if (this._xformMode == this._ENC_XFORM_MODE) { a.pad(this._data, this.blockSize); var b = this._process(!0) } else b = this._process(!0), a.unpad(b); return b }, blockSize: 4
	}); var p = f.CipherParams = k.extend({ init: function (a) { this.mixIn(a) }, toString: function (a) { return (a || this.formatter).stringify(this) } }), m = (g.format = {}).OpenSSL = {
		stringify: function (a) {
			var b = a.ciphertext; a = a.salt;
			return (a ? l.create([1398893684, 1701076831]).concat(a).concat(b) : b).toString(r)
		}, parse: function (a) { a = r.parse(a); var b = a.words; if (1398893684 == b[0] && 1701076831 == b[1]) { var c = l.create(b.slice(2, 4)); b.splice(0, 4); a.sigBytes -= 16 } return p.create({ ciphertext: a, salt: c }) }
	}, j = f.SerializableCipher = k.extend({
		cfg: k.extend({ format: m }), encrypt: function (a, b, c, d) {
			d = this.cfg.extend(d); var e = a.createEncryptor(c, d); b = e.finalize(b); e = e.cfg; return p.create({
				ciphertext: b, key: c, iv: e.iv, algorithm: a, mode: e.mode, padding: e.padding,
				blockSize: a.blockSize, formatter: d.format
			})
		}, decrypt: function (a, b, c, d) { d = this.cfg.extend(d); b = this._parse(b, d.format); return a.createDecryptor(c, d).finalize(b.ciphertext) }, _parse: function (a, b) { return "string" == typeof a ? b.parse(a, this) : a }
	}), g = (g.kdf = {}).OpenSSL = { execute: function (a, b, c, d) { d || (d = l.random(8)); a = v.create({ keySize: b + c }).compute(a, d); c = l.create(a.words.slice(b), 4 * c); a.sigBytes = 4 * b; return p.create({ key: a, iv: c, salt: d }) } }, s = f.PasswordBasedCipher = j.extend({
		cfg: j.cfg.extend({ kdf: g }), encrypt: function (a,
			b, c, d) { d = this.cfg.extend(d); c = d.kdf.execute(c, a.keySize, a.ivSize); d.iv = c.iv; a = j.encrypt.call(this, a, b, c.key, d); a.mixIn(c); return a }, decrypt: function (a, b, c, d) { d = this.cfg.extend(d); b = this._parse(b, d.format); c = d.kdf.execute(c, a.keySize, a.ivSize, b.salt); d.iv = c.iv; return j.decrypt.call(this, a, b, c.key, d) }
	})
}();

/*
CryptoJS v3.1.2 enc-base64.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
	var h = CryptoJS, j = h.lib.WordArray; h.enc.Base64 = {
		stringify: function (b) { var e = b.words, f = b.sigBytes, c = this._map; b.clamp(); b = []; for (var a = 0; a < f; a += 3)for (var d = (e[a >>> 2] >>> 24 - 8 * (a % 4) & 255) << 16 | (e[a + 1 >>> 2] >>> 24 - 8 * ((a + 1) % 4) & 255) << 8 | e[a + 2 >>> 2] >>> 24 - 8 * ((a + 2) % 4) & 255, g = 0; 4 > g && a + 0.75 * g < f; g++)b.push(c.charAt(d >>> 6 * (3 - g) & 63)); if (e = c.charAt(64)) for (; b.length % 4;)b.push(e); return b.join("") }, parse: function (b) {
			var e = b.length, f = this._map, c = f.charAt(64); c && (c = b.indexOf(c), -1 != c && (e = c)); for (var c = [], a = 0, d = 0; d <
				e; d++)if (d % 4) { var g = f.indexOf(b.charAt(d - 1)) << 2 * (d % 4), h = f.indexOf(b.charAt(d)) >>> 6 - 2 * (d % 4); c[a >>> 2] |= (g | h) << 24 - 8 * (a % 4); a++ } return j.create(c, a)
		}, _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
	}
})();

/*
CryptoJS v3.1.2 sha1-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
	var k = CryptoJS, b = k.lib, m = b.WordArray, l = b.Hasher, d = [], b = k.algo.SHA1 = l.extend({
		_doReset: function () { this._hash = new m.init([1732584193, 4023233417, 2562383102, 271733878, 3285377520]) }, _doProcessBlock: function (n, p) {
			for (var a = this._hash.words, e = a[0], f = a[1], h = a[2], j = a[3], b = a[4], c = 0; 80 > c; c++) {
				if (16 > c) d[c] = n[p + c] | 0; else { var g = d[c - 3] ^ d[c - 8] ^ d[c - 14] ^ d[c - 16]; d[c] = g << 1 | g >>> 31 } g = (e << 5 | e >>> 27) + b + d[c]; g = 20 > c ? g + ((f & h | ~f & j) + 1518500249) : 40 > c ? g + ((f ^ h ^ j) + 1859775393) : 60 > c ? g + ((f & h | f & j | h & j) - 1894007588) : g + ((f ^ h ^
					j) - 899497514); b = j; j = h; h = f << 30 | f >>> 2; f = e; e = g
			} a[0] = a[0] + e | 0; a[1] = a[1] + f | 0; a[2] = a[2] + h | 0; a[3] = a[3] + j | 0; a[4] = a[4] + b | 0
		}, _doFinalize: function () { var b = this._data, d = b.words, a = 8 * this._nDataBytes, e = 8 * b.sigBytes; d[e >>> 5] |= 128 << 24 - e % 32; d[(e + 64 >>> 9 << 4) + 14] = Math.floor(a / 4294967296); d[(e + 64 >>> 9 << 4) + 15] = a; b.sigBytes = 4 * d.length; this._process(); return this._hash }, clone: function () { var b = l.clone.call(this); b._hash = this._hash.clone(); return b }
	}); k.SHA1 = l._createHelper(b); k.HmacSHA1 = l._createHmacHelper(b)
})();

/*
CryptoJS v3.1.2 sha256-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function (k) {
	for (var g = CryptoJS, h = g.lib, v = h.WordArray, j = h.Hasher, h = g.algo, s = [], t = [], u = function (q) { return 4294967296 * (q - (q | 0)) | 0 }, l = 2, b = 0; 64 > b;) { var d; a: { d = l; for (var w = k.sqrt(d), r = 2; r <= w; r++)if (!(d % r)) { d = !1; break a } d = !0 } d && (8 > b && (s[b] = u(k.pow(l, 0.5))), t[b] = u(k.pow(l, 1 / 3)), b++); l++ } var n = [], h = h.SHA256 = j.extend({
		_doReset: function () { this._hash = new v.init(s.slice(0)) }, _doProcessBlock: function (q, h) {
			for (var a = this._hash.words, c = a[0], d = a[1], b = a[2], k = a[3], f = a[4], g = a[5], j = a[6], l = a[7], e = 0; 64 > e; e++) {
				if (16 > e) n[e] =
					q[h + e] | 0; else { var m = n[e - 15], p = n[e - 2]; n[e] = ((m << 25 | m >>> 7) ^ (m << 14 | m >>> 18) ^ m >>> 3) + n[e - 7] + ((p << 15 | p >>> 17) ^ (p << 13 | p >>> 19) ^ p >>> 10) + n[e - 16] } m = l + ((f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25)) + (f & g ^ ~f & j) + t[e] + n[e]; p = ((c << 30 | c >>> 2) ^ (c << 19 | c >>> 13) ^ (c << 10 | c >>> 22)) + (c & d ^ c & b ^ d & b); l = j; j = g; g = f; f = k + m | 0; k = b; b = d; d = c; c = m + p | 0
			} a[0] = a[0] + c | 0; a[1] = a[1] + d | 0; a[2] = a[2] + b | 0; a[3] = a[3] + k | 0; a[4] = a[4] + f | 0; a[5] = a[5] + g | 0; a[6] = a[6] + j | 0; a[7] = a[7] + l | 0
		}, _doFinalize: function () {
			var d = this._data, b = d.words, a = 8 * this._nDataBytes, c = 8 * d.sigBytes;
			b[c >>> 5] |= 128 << 24 - c % 32; b[(c + 64 >>> 9 << 4) + 14] = k.floor(a / 4294967296); b[(c + 64 >>> 9 << 4) + 15] = a; d.sigBytes = 4 * b.length; this._process(); return this._hash
		}, clone: function () { var b = j.clone.call(this); b._hash = this._hash.clone(); return b }
	}); g.SHA256 = j._createHelper(h); g.HmacSHA256 = j._createHmacHelper(h)
})(Math);

/*
CryptoJS v3.1.2 sha512-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
	function a() { return d.create.apply(d, arguments) } for (var n = CryptoJS, r = n.lib.Hasher, e = n.x64, d = e.Word, T = e.WordArray, e = n.algo, ea = [a(1116352408, 3609767458), a(1899447441, 602891725), a(3049323471, 3964484399), a(3921009573, 2173295548), a(961987163, 4081628472), a(1508970993, 3053834265), a(2453635748, 2937671579), a(2870763221, 3664609560), a(3624381080, 2734883394), a(310598401, 1164996542), a(607225278, 1323610764), a(1426881987, 3590304994), a(1925078388, 4068182383), a(2162078206, 991336113), a(2614888103, 633803317),
	a(3248222580, 3479774868), a(3835390401, 2666613458), a(4022224774, 944711139), a(264347078, 2341262773), a(604807628, 2007800933), a(770255983, 1495990901), a(1249150122, 1856431235), a(1555081692, 3175218132), a(1996064986, 2198950837), a(2554220882, 3999719339), a(2821834349, 766784016), a(2952996808, 2566594879), a(3210313671, 3203337956), a(3336571891, 1034457026), a(3584528711, 2466948901), a(113926993, 3758326383), a(338241895, 168717936), a(666307205, 1188179964), a(773529912, 1546045734), a(1294757372, 1522805485), a(1396182291,
		2643833823), a(1695183700, 2343527390), a(1986661051, 1014477480), a(2177026350, 1206759142), a(2456956037, 344077627), a(2730485921, 1290863460), a(2820302411, 3158454273), a(3259730800, 3505952657), a(3345764771, 106217008), a(3516065817, 3606008344), a(3600352804, 1432725776), a(4094571909, 1467031594), a(275423344, 851169720), a(430227734, 3100823752), a(506948616, 1363258195), a(659060556, 3750685593), a(883997877, 3785050280), a(958139571, 3318307427), a(1322822218, 3812723403), a(1537002063, 2003034995), a(1747873779, 3602036899),
	a(1955562222, 1575990012), a(2024104815, 1125592928), a(2227730452, 2716904306), a(2361852424, 442776044), a(2428436474, 593698344), a(2756734187, 3733110249), a(3204031479, 2999351573), a(3329325298, 3815920427), a(3391569614, 3928383900), a(3515267271, 566280711), a(3940187606, 3454069534), a(4118630271, 4000239992), a(116418474, 1914138554), a(174292421, 2731055270), a(289380356, 3203993006), a(460393269, 320620315), a(685471733, 587496836), a(852142971, 1086792851), a(1017036298, 365543100), a(1126000580, 2618297676), a(1288033470,
		3409855158), a(1501505948, 4234509866), a(1607167915, 987167468), a(1816402316, 1246189591)], v = [], w = 0; 80 > w; w++)v[w] = a(); e = e.SHA512 = r.extend({
			_doReset: function () { this._hash = new T.init([new d.init(1779033703, 4089235720), new d.init(3144134277, 2227873595), new d.init(1013904242, 4271175723), new d.init(2773480762, 1595750129), new d.init(1359893119, 2917565137), new d.init(2600822924, 725511199), new d.init(528734635, 4215389547), new d.init(1541459225, 327033209)]) }, _doProcessBlock: function (a, d) {
				for (var f = this._hash.words,
					F = f[0], e = f[1], n = f[2], r = f[3], G = f[4], H = f[5], I = f[6], f = f[7], w = F.high, J = F.low, X = e.high, K = e.low, Y = n.high, L = n.low, Z = r.high, M = r.low, $ = G.high, N = G.low, aa = H.high, O = H.low, ba = I.high, P = I.low, ca = f.high, Q = f.low, k = w, g = J, z = X, x = K, A = Y, y = L, U = Z, B = M, l = $, h = N, R = aa, C = O, S = ba, D = P, V = ca, E = Q, m = 0; 80 > m; m++) {
					var s = v[m]; if (16 > m) var j = s.high = a[d + 2 * m] | 0, b = s.low = a[d + 2 * m + 1] | 0; else {
						var j = v[m - 15], b = j.high, p = j.low, j = (b >>> 1 | p << 31) ^ (b >>> 8 | p << 24) ^ b >>> 7, p = (p >>> 1 | b << 31) ^ (p >>> 8 | b << 24) ^ (p >>> 7 | b << 25), u = v[m - 2], b = u.high, c = u.low, u = (b >>> 19 | c << 13) ^ (b <<
							3 | c >>> 29) ^ b >>> 6, c = (c >>> 19 | b << 13) ^ (c << 3 | b >>> 29) ^ (c >>> 6 | b << 26), b = v[m - 7], W = b.high, t = v[m - 16], q = t.high, t = t.low, b = p + b.low, j = j + W + (b >>> 0 < p >>> 0 ? 1 : 0), b = b + c, j = j + u + (b >>> 0 < c >>> 0 ? 1 : 0), b = b + t, j = j + q + (b >>> 0 < t >>> 0 ? 1 : 0); s.high = j; s.low = b
					} var W = l & R ^ ~l & S, t = h & C ^ ~h & D, s = k & z ^ k & A ^ z & A, T = g & x ^ g & y ^ x & y, p = (k >>> 28 | g << 4) ^ (k << 30 | g >>> 2) ^ (k << 25 | g >>> 7), u = (g >>> 28 | k << 4) ^ (g << 30 | k >>> 2) ^ (g << 25 | k >>> 7), c = ea[m], fa = c.high, da = c.low, c = E + ((h >>> 14 | l << 18) ^ (h >>> 18 | l << 14) ^ (h << 23 | l >>> 9)), q = V + ((l >>> 14 | h << 18) ^ (l >>> 18 | h << 14) ^ (l << 23 | h >>> 9)) + (c >>> 0 < E >>> 0 ? 1 :
						0), c = c + t, q = q + W + (c >>> 0 < t >>> 0 ? 1 : 0), c = c + da, q = q + fa + (c >>> 0 < da >>> 0 ? 1 : 0), c = c + b, q = q + j + (c >>> 0 < b >>> 0 ? 1 : 0), b = u + T, s = p + s + (b >>> 0 < u >>> 0 ? 1 : 0), V = S, E = D, S = R, D = C, R = l, C = h, h = B + c | 0, l = U + q + (h >>> 0 < B >>> 0 ? 1 : 0) | 0, U = A, B = y, A = z, y = x, z = k, x = g, g = c + b | 0, k = q + s + (g >>> 0 < c >>> 0 ? 1 : 0) | 0
				} J = F.low = J + g; F.high = w + k + (J >>> 0 < g >>> 0 ? 1 : 0); K = e.low = K + x; e.high = X + z + (K >>> 0 < x >>> 0 ? 1 : 0); L = n.low = L + y; n.high = Y + A + (L >>> 0 < y >>> 0 ? 1 : 0); M = r.low = M + B; r.high = Z + U + (M >>> 0 < B >>> 0 ? 1 : 0); N = G.low = N + h; G.high = $ + l + (N >>> 0 < h >>> 0 ? 1 : 0); O = H.low = O + C; H.high = aa + R + (O >>> 0 < C >>> 0 ? 1 : 0); P = I.low = P + D;
				I.high = ba + S + (P >>> 0 < D >>> 0 ? 1 : 0); Q = f.low = Q + E; f.high = ca + V + (Q >>> 0 < E >>> 0 ? 1 : 0)
			}, _doFinalize: function () { var a = this._data, d = a.words, f = 8 * this._nDataBytes, e = 8 * a.sigBytes; d[e >>> 5] |= 128 << 24 - e % 32; d[(e + 128 >>> 10 << 5) + 30] = Math.floor(f / 4294967296); d[(e + 128 >>> 10 << 5) + 31] = f; a.sigBytes = 4 * d.length; this._process(); return this._hash.toX32() }, clone: function () { var a = r.clone.call(this); a._hash = this._hash.clone(); return a }, blockSize: 32
		}); n.SHA512 = r._createHelper(e); n.HmacSHA512 = r._createHmacHelper(e)
})();

/*
CryptoJS v3.1.2 sha384-min.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
	var c = CryptoJS, a = c.x64, b = a.Word, e = a.WordArray, a = c.algo, d = a.SHA512, a = a.SHA384 = d.extend({ _doReset: function () { this._hash = new e.init([new b.init(3418070365, 3238371032), new b.init(1654270250, 914150663), new b.init(2438529370, 812702999), new b.init(355462360, 4144912697), new b.init(1731405415, 4290775857), new b.init(2394180231, 1750603025), new b.init(3675008525, 1694076839), new b.init(1203062813, 3204075428)]) }, _doFinalize: function () { var a = d._doFinalize.call(this); a.sigBytes -= 16; return a } }); c.SHA384 =
		d._createHelper(a); c.HmacSHA384 = d._createHmacHelper(a)
})();

/*
CryptoJS v3.1.2 hmac.js
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
(function () {
	var c = CryptoJS, k = c.enc.Utf8; c.algo.HMAC = c.lib.Base.extend({
		init: function (a, b) { a = this._hasher = new a.init; "string" == typeof b && (b = k.parse(b)); var c = a.blockSize, e = 4 * c; b.sigBytes > e && (b = a.finalize(b)); b.clamp(); for (var f = this._oKey = b.clone(), g = this._iKey = b.clone(), h = f.words, j = g.words, d = 0; d < c; d++)h[d] ^= 1549556828, j[d] ^= 909522486; f.sigBytes = g.sigBytes = e; this.reset() }, reset: function () { var a = this._hasher; a.reset(); a.update(this._iKey) }, update: function (a) { this._hasher.update(a); return this }, finalize: function (a) {
			var b =
				this._hasher; a = b.finalize(a); b.reset(); return b.finalize(this._oKey.clone().concat(a))
		}
	})
})();

/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var b64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"; var b64pad = "="; function hex2b64(d) { var b; var e; var a = ""; for (b = 0; b + 3 <= d.length; b += 3) { e = parseInt(d.substring(b, b + 3), 16); a += b64map.charAt(e >> 6) + b64map.charAt(e & 63) } if (b + 1 == d.length) { e = parseInt(d.substring(b, b + 1), 16); a += b64map.charAt(e << 2) } else { if (b + 2 == d.length) { e = parseInt(d.substring(b, b + 2), 16); a += b64map.charAt(e >> 2) + b64map.charAt((e & 3) << 4) } } if (b64pad) { while ((a.length & 3) > 0) { a += b64pad } } return a } function b64tohex(f) { var d = ""; var e; var b = 0; var c; var a; for (e = 0; e < f.length; ++e) { if (f.charAt(e) == b64pad) { break } a = b64map.indexOf(f.charAt(e)); if (a < 0) { continue } if (b == 0) { d += int2char(a >> 2); c = a & 3; b = 1 } else { if (b == 1) { d += int2char((c << 2) | (a >> 4)); c = a & 15; b = 2 } else { if (b == 2) { d += int2char(c); d += int2char(a >> 2); c = a & 3; b = 3 } else { d += int2char((c << 2) | (a >> 4)); d += int2char(a & 15); b = 0 } } } } if (b == 1) { d += int2char(c << 2) } return d } function b64toBA(e) { var d = b64tohex(e); var c; var b = new Array(); for (c = 0; 2 * c < d.length; ++c) { b[c] = parseInt(d.substring(2 * c, 2 * c + 2), 16) } return b };
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var dbits; var canary = 244837814094590; var j_lm = ((canary & 16777215) == 15715070); function BigInteger(e, d, f) { if (e != null) { if ("number" == typeof e) { this.fromNumber(e, d, f) } else { if (d == null && "string" != typeof e) { this.fromString(e, 256) } else { this.fromString(e, d) } } } } function nbi() { return new BigInteger(null) } function am1(f, a, b, e, h, g) { while (--g >= 0) { var d = a * this[f++] + b[e] + h; h = Math.floor(d / 67108864); b[e++] = d & 67108863 } return h } function am2(f, q, r, e, o, a) { var k = q & 32767, p = q >> 15; while (--a >= 0) { var d = this[f] & 32767; var g = this[f++] >> 15; var b = p * d + g * k; d = k * d + ((b & 32767) << 15) + r[e] + (o & 1073741823); o = (d >>> 30) + (b >>> 15) + p * g + (o >>> 30); r[e++] = d & 1073741823 } return o } function am3(f, q, r, e, o, a) { var k = q & 16383, p = q >> 14; while (--a >= 0) { var d = this[f] & 16383; var g = this[f++] >> 14; var b = p * d + g * k; d = k * d + ((b & 16383) << 14) + r[e] + o; o = (d >> 28) + (b >> 14) + p * g; r[e++] = d & 268435455 } return o } if (j_lm && (navigator.appName == "Microsoft Internet Explorer")) { BigInteger.prototype.am = am2; dbits = 30 } else { if (j_lm && (navigator.appName != "Netscape")) { BigInteger.prototype.am = am1; dbits = 26 } else { BigInteger.prototype.am = am3; dbits = 28 } } BigInteger.prototype.DB = dbits; BigInteger.prototype.DM = ((1 << dbits) - 1); BigInteger.prototype.DV = (1 << dbits); var BI_FP = 52; BigInteger.prototype.FV = Math.pow(2, BI_FP); BigInteger.prototype.F1 = BI_FP - dbits; BigInteger.prototype.F2 = 2 * dbits - BI_FP; var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz"; var BI_RC = new Array(); var rr, vv; rr = "0".charCodeAt(0); for (vv = 0; vv <= 9; ++vv) { BI_RC[rr++] = vv } rr = "a".charCodeAt(0); for (vv = 10; vv < 36; ++vv) { BI_RC[rr++] = vv } rr = "A".charCodeAt(0); for (vv = 10; vv < 36; ++vv) { BI_RC[rr++] = vv } function int2char(a) { return BI_RM.charAt(a) } function intAt(b, a) { var d = BI_RC[b.charCodeAt(a)]; return (d == null) ? -1 : d } function bnpCopyTo(b) { for (var a = this.t - 1; a >= 0; --a) { b[a] = this[a] } b.t = this.t; b.s = this.s } function bnpFromInt(a) { this.t = 1; this.s = (a < 0) ? -1 : 0; if (a > 0) { this[0] = a } else { if (a < -1) { this[0] = a + this.DV } else { this.t = 0 } } } function nbv(a) { var b = nbi(); b.fromInt(a); return b } function bnpFromString(h, c) { var e; if (c == 16) { e = 4 } else { if (c == 8) { e = 3 } else { if (c == 256) { e = 8 } else { if (c == 2) { e = 1 } else { if (c == 32) { e = 5 } else { if (c == 4) { e = 2 } else { this.fromRadix(h, c); return } } } } } } this.t = 0; this.s = 0; var g = h.length, d = false, f = 0; while (--g >= 0) { var a = (e == 8) ? h[g] & 255 : intAt(h, g); if (a < 0) { if (h.charAt(g) == "-") { d = true } continue } d = false; if (f == 0) { this[this.t++] = a } else { if (f + e > this.DB) { this[this.t - 1] |= (a & ((1 << (this.DB - f)) - 1)) << f; this[this.t++] = (a >> (this.DB - f)) } else { this[this.t - 1] |= a << f } } f += e; if (f >= this.DB) { f -= this.DB } } if (e == 8 && (h[0] & 128) != 0) { this.s = -1; if (f > 0) { this[this.t - 1] |= ((1 << (this.DB - f)) - 1) << f } } this.clamp(); if (d) { BigInteger.ZERO.subTo(this, this) } } function bnpClamp() { var a = this.s & this.DM; while (this.t > 0 && this[this.t - 1] == a) { --this.t } } function bnToString(c) { if (this.s < 0) { return "-" + this.negate().toString(c) } var e; if (c == 16) { e = 4 } else { if (c == 8) { e = 3 } else { if (c == 2) { e = 1 } else { if (c == 32) { e = 5 } else { if (c == 4) { e = 2 } else { return this.toRadix(c) } } } } } var g = (1 << e) - 1, l, a = false, h = "", f = this.t; var j = this.DB - (f * this.DB) % e; if (f-- > 0) { if (j < this.DB && (l = this[f] >> j) > 0) { a = true; h = int2char(l) } while (f >= 0) { if (j < e) { l = (this[f] & ((1 << j) - 1)) << (e - j); l |= this[--f] >> (j += this.DB - e) } else { l = (this[f] >> (j -= e)) & g; if (j <= 0) { j += this.DB; --f } } if (l > 0) { a = true } if (a) { h += int2char(l) } } } return a ? h : "0" } function bnNegate() { var a = nbi(); BigInteger.ZERO.subTo(this, a); return a } function bnAbs() { return (this.s < 0) ? this.negate() : this } function bnCompareTo(b) { var d = this.s - b.s; if (d != 0) { return d } var c = this.t; d = c - b.t; if (d != 0) { return (this.s < 0) ? -d : d } while (--c >= 0) { if ((d = this[c] - b[c]) != 0) { return d } } return 0 } function nbits(a) { var c = 1, b; if ((b = a >>> 16) != 0) { a = b; c += 16 } if ((b = a >> 8) != 0) { a = b; c += 8 } if ((b = a >> 4) != 0) { a = b; c += 4 } if ((b = a >> 2) != 0) { a = b; c += 2 } if ((b = a >> 1) != 0) { a = b; c += 1 } return c } function bnBitLength() { if (this.t <= 0) { return 0 } return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ (this.s & this.DM)) } function bnpDLShiftTo(c, b) { var a; for (a = this.t - 1; a >= 0; --a) { b[a + c] = this[a] } for (a = c - 1; a >= 0; --a) { b[a] = 0 } b.t = this.t + c; b.s = this.s } function bnpDRShiftTo(c, b) { for (var a = c; a < this.t; ++a) { b[a - c] = this[a] } b.t = Math.max(this.t - c, 0); b.s = this.s } function bnpLShiftTo(j, e) { var b = j % this.DB; var a = this.DB - b; var g = (1 << a) - 1; var f = Math.floor(j / this.DB), h = (this.s << b) & this.DM, d; for (d = this.t - 1; d >= 0; --d) { e[d + f + 1] = (this[d] >> a) | h; h = (this[d] & g) << b } for (d = f - 1; d >= 0; --d) { e[d] = 0 } e[f] = h; e.t = this.t + f + 1; e.s = this.s; e.clamp() } function bnpRShiftTo(g, d) { d.s = this.s; var e = Math.floor(g / this.DB); if (e >= this.t) { d.t = 0; return } var b = g % this.DB; var a = this.DB - b; var f = (1 << b) - 1; d[0] = this[e] >> b; for (var c = e + 1; c < this.t; ++c) { d[c - e - 1] |= (this[c] & f) << a; d[c - e] = this[c] >> b } if (b > 0) { d[this.t - e - 1] |= (this.s & f) << a } d.t = this.t - e; d.clamp() } function bnpSubTo(d, f) { var e = 0, g = 0, b = Math.min(d.t, this.t); while (e < b) { g += this[e] - d[e]; f[e++] = g & this.DM; g >>= this.DB } if (d.t < this.t) { g -= d.s; while (e < this.t) { g += this[e]; f[e++] = g & this.DM; g >>= this.DB } g += this.s } else { g += this.s; while (e < d.t) { g -= d[e]; f[e++] = g & this.DM; g >>= this.DB } g -= d.s } f.s = (g < 0) ? -1 : 0; if (g < -1) { f[e++] = this.DV + g } else { if (g > 0) { f[e++] = g } } f.t = e; f.clamp() } function bnpMultiplyTo(c, e) { var b = this.abs(), f = c.abs(); var d = b.t; e.t = d + f.t; while (--d >= 0) { e[d] = 0 } for (d = 0; d < f.t; ++d) { e[d + b.t] = b.am(0, f[d], e, d, 0, b.t) } e.s = 0; e.clamp(); if (this.s != c.s) { BigInteger.ZERO.subTo(e, e) } } function bnpSquareTo(d) { var a = this.abs(); var b = d.t = 2 * a.t; while (--b >= 0) { d[b] = 0 } for (b = 0; b < a.t - 1; ++b) { var e = a.am(b, a[b], d, 2 * b, 0, 1); if ((d[b + a.t] += a.am(b + 1, 2 * a[b], d, 2 * b + 1, e, a.t - b - 1)) >= a.DV) { d[b + a.t] -= a.DV; d[b + a.t + 1] = 1 } } if (d.t > 0) { d[d.t - 1] += a.am(b, a[b], d, 2 * b, 0, 1) } d.s = 0; d.clamp() } function bnpDivRemTo(n, h, g) { var w = n.abs(); if (w.t <= 0) { return } var k = this.abs(); if (k.t < w.t) { if (h != null) { h.fromInt(0) } if (g != null) { this.copyTo(g) } return } if (g == null) { g = nbi() } var d = nbi(), a = this.s, l = n.s; var v = this.DB - nbits(w[w.t - 1]); if (v > 0) { w.lShiftTo(v, d); k.lShiftTo(v, g) } else { w.copyTo(d); k.copyTo(g) } var p = d.t; var b = d[p - 1]; if (b == 0) { return } var o = b * (1 << this.F1) + ((p > 1) ? d[p - 2] >> this.F2 : 0); var A = this.FV / o, z = (1 << this.F1) / o, x = 1 << this.F2; var u = g.t, s = u - p, f = (h == null) ? nbi() : h; d.dlShiftTo(s, f); if (g.compareTo(f) >= 0) { g[g.t++] = 1; g.subTo(f, g) } BigInteger.ONE.dlShiftTo(p, f); f.subTo(d, d); while (d.t < p) { d[d.t++] = 0 } while (--s >= 0) { var c = (g[--u] == b) ? this.DM : Math.floor(g[u] * A + (g[u - 1] + x) * z); if ((g[u] += d.am(0, c, g, s, 0, p)) < c) { d.dlShiftTo(s, f); g.subTo(f, g); while (g[u] < --c) { g.subTo(f, g) } } } if (h != null) { g.drShiftTo(p, h); if (a != l) { BigInteger.ZERO.subTo(h, h) } } g.t = p; g.clamp(); if (v > 0) { g.rShiftTo(v, g) } if (a < 0) { BigInteger.ZERO.subTo(g, g) } } function bnMod(b) { var c = nbi(); this.abs().divRemTo(b, null, c); if (this.s < 0 && c.compareTo(BigInteger.ZERO) > 0) { b.subTo(c, c) } return c } function Classic(a) { this.m = a } function cConvert(a) { if (a.s < 0 || a.compareTo(this.m) >= 0) { return a.mod(this.m) } else { return a } } function cRevert(a) { return a } function cReduce(a) { a.divRemTo(this.m, null, a) } function cMulTo(a, c, b) { a.multiplyTo(c, b); this.reduce(b) } function cSqrTo(a, b) { a.squareTo(b); this.reduce(b) } Classic.prototype.convert = cConvert; Classic.prototype.revert = cRevert; Classic.prototype.reduce = cReduce; Classic.prototype.mulTo = cMulTo; Classic.prototype.sqrTo = cSqrTo; function bnpInvDigit() { if (this.t < 1) { return 0 } var a = this[0]; if ((a & 1) == 0) { return 0 } var b = a & 3; b = (b * (2 - (a & 15) * b)) & 15; b = (b * (2 - (a & 255) * b)) & 255; b = (b * (2 - (((a & 65535) * b) & 65535))) & 65535; b = (b * (2 - a * b % this.DV)) % this.DV; return (b > 0) ? this.DV - b : -b } function Montgomery(a) { this.m = a; this.mp = a.invDigit(); this.mpl = this.mp & 32767; this.mph = this.mp >> 15; this.um = (1 << (a.DB - 15)) - 1; this.mt2 = 2 * a.t } function montConvert(a) { var b = nbi(); a.abs().dlShiftTo(this.m.t, b); b.divRemTo(this.m, null, b); if (a.s < 0 && b.compareTo(BigInteger.ZERO) > 0) { this.m.subTo(b, b) } return b } function montRevert(a) { var b = nbi(); a.copyTo(b); this.reduce(b); return b } function montReduce(a) { while (a.t <= this.mt2) { a[a.t++] = 0 } for (var c = 0; c < this.m.t; ++c) { var b = a[c] & 32767; var d = (b * this.mpl + (((b * this.mph + (a[c] >> 15) * this.mpl) & this.um) << 15)) & a.DM; b = c + this.m.t; a[b] += this.m.am(0, d, a, c, 0, this.m.t); while (a[b] >= a.DV) { a[b] -= a.DV; a[++b]++ } } a.clamp(); a.drShiftTo(this.m.t, a); if (a.compareTo(this.m) >= 0) { a.subTo(this.m, a) } } function montSqrTo(a, b) { a.squareTo(b); this.reduce(b) } function montMulTo(a, c, b) { a.multiplyTo(c, b); this.reduce(b) } Montgomery.prototype.convert = montConvert; Montgomery.prototype.revert = montRevert; Montgomery.prototype.reduce = montReduce; Montgomery.prototype.mulTo = montMulTo; Montgomery.prototype.sqrTo = montSqrTo; function bnpIsEven() { return ((this.t > 0) ? (this[0] & 1) : this.s) == 0 } function bnpExp(h, j) { if (h > 4294967295 || h < 1) { return BigInteger.ONE } var f = nbi(), a = nbi(), d = j.convert(this), c = nbits(h) - 1; d.copyTo(f); while (--c >= 0) { j.sqrTo(f, a); if ((h & (1 << c)) > 0) { j.mulTo(a, d, f) } else { var b = f; f = a; a = b } } return j.revert(f) } function bnModPowInt(b, a) { var c; if (b < 256 || a.isEven()) { c = new Classic(a) } else { c = new Montgomery(a) } return this.exp(b, c) } BigInteger.prototype.copyTo = bnpCopyTo; BigInteger.prototype.fromInt = bnpFromInt; BigInteger.prototype.fromString = bnpFromString; BigInteger.prototype.clamp = bnpClamp; BigInteger.prototype.dlShiftTo = bnpDLShiftTo; BigInteger.prototype.drShiftTo = bnpDRShiftTo; BigInteger.prototype.lShiftTo = bnpLShiftTo; BigInteger.prototype.rShiftTo = bnpRShiftTo; BigInteger.prototype.subTo = bnpSubTo; BigInteger.prototype.multiplyTo = bnpMultiplyTo; BigInteger.prototype.squareTo = bnpSquareTo; BigInteger.prototype.divRemTo = bnpDivRemTo; BigInteger.prototype.invDigit = bnpInvDigit; BigInteger.prototype.isEven = bnpIsEven; BigInteger.prototype.exp = bnpExp; BigInteger.prototype.toString = bnToString; BigInteger.prototype.negate = bnNegate; BigInteger.prototype.abs = bnAbs; BigInteger.prototype.compareTo = bnCompareTo; BigInteger.prototype.bitLength = bnBitLength; BigInteger.prototype.mod = bnMod; BigInteger.prototype.modPowInt = bnModPowInt; BigInteger.ZERO = nbv(0); BigInteger.ONE = nbv(1);
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function Arcfour() { this.i = 0; this.j = 0; this.S = new Array() } function ARC4init(d) { var c, a, b; for (c = 0; c < 256; ++c) { this.S[c] = c } a = 0; for (c = 0; c < 256; ++c) { a = (a + this.S[c] + d[c % d.length]) & 255; b = this.S[c]; this.S[c] = this.S[a]; this.S[a] = b } this.i = 0; this.j = 0 } function ARC4next() { var a; this.i = (this.i + 1) & 255; this.j = (this.j + this.S[this.i]) & 255; a = this.S[this.i]; this.S[this.i] = this.S[this.j]; this.S[this.j] = a; return this.S[(a + this.S[this.i]) & 255] } Arcfour.prototype.init = ARC4init; Arcfour.prototype.next = ARC4next; function prng_newstate() { return new Arcfour() } var rng_psize = 256;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var rng_state; var rng_pool; var rng_pptr; function rng_seed_int(a) { rng_pool[rng_pptr++] ^= a & 255; rng_pool[rng_pptr++] ^= (a >> 8) & 255; rng_pool[rng_pptr++] ^= (a >> 16) & 255; rng_pool[rng_pptr++] ^= (a >> 24) & 255; if (rng_pptr >= rng_psize) { rng_pptr -= rng_psize } } function rng_seed_time() { rng_seed_int(new Date().getTime()) } if (rng_pool == null) { rng_pool = new Array(); rng_pptr = 0; var t; if (window !== undefined && (window.crypto !== undefined || window.msCrypto !== undefined)) { var crypto = window.crypto || window.msCrypto; if (crypto.getRandomValues) { var ua = new Uint8Array(32); crypto.getRandomValues(ua); for (t = 0; t < 32; ++t) { rng_pool[rng_pptr++] = ua[t] } } else { if (navigator.appName == "Netscape" && navigator.appVersion < "5") { var z = window.crypto.random(32); for (t = 0; t < z.length; ++t) { rng_pool[rng_pptr++] = z.charCodeAt(t) & 255 } } } } while (rng_pptr < rng_psize) { t = Math.floor(65536 * Math.random()); rng_pool[rng_pptr++] = t >>> 8; rng_pool[rng_pptr++] = t & 255 } rng_pptr = 0; rng_seed_time() } function rng_get_byte() { if (rng_state == null) { rng_seed_time(); rng_state = prng_newstate(); rng_state.init(rng_pool); for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr) { rng_pool[rng_pptr] = 0 } rng_pptr = 0 } return rng_state.next() } function rng_get_bytes(b) { var a; for (a = 0; a < b.length; ++a) { b[a] = rng_get_byte() } } function SecureRandom() { } SecureRandom.prototype.nextBytes = rng_get_bytes;
/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
 */
var jsonParse = (function () { var e = "(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)"; var j = '(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))'; var i = '(?:"' + j + '*")'; var d = new RegExp("(?:false|true|null|[\\{\\}\\[\\]]|" + e + "|" + i + ")", "g"); var k = new RegExp("\\\\(?:([^u])|u(.{4}))", "g"); var g = { '"': '"', "/": "/", "\\": "\\", b: "\b", f: "\f", n: "\n", r: "\r", t: "\t" }; function h(l, m, n) { return m ? g[m] : String.fromCharCode(parseInt(n, 16)) } var c = new String(""); var a = "\\"; var f = { "{": Object, "[": Array }; var b = Object.hasOwnProperty; return function (u, q) { var p = u.match(d); var x; var v = p[0]; var l = false; if ("{" === v) { x = {} } else { if ("[" === v) { x = [] } else { x = []; l = true } } var t; var r = [x]; for (var o = 1 - l, m = p.length; o < m; ++o) { v = p[o]; var w; switch (v.charCodeAt(0)) { default: w = r[0]; w[t || w.length] = +(v); t = void 0; break; case 34: v = v.substring(1, v.length - 1); if (v.indexOf(a) !== -1) { v = v.replace(k, h) } w = r[0]; if (!t) { if (w instanceof Array) { t = w.length } else { t = v || c; break } } w[t] = v; t = void 0; break; case 91: w = r[0]; r.unshift(w[t || w.length] = []); t = void 0; break; case 93: r.shift(); break; case 102: w = r[0]; w[t || w.length] = false; t = void 0; break; case 110: w = r[0]; w[t || w.length] = null; t = void 0; break; case 116: w = r[0]; w[t || w.length] = true; t = void 0; break; case 123: w = r[0]; r.unshift(w[t || w.length] = {}); t = void 0; break; case 125: r.shift(); break } } if (l) { if (r.length !== 1) { throw new Error() } x = x[0] } else { if (r.length) { throw new Error() } } if (q) { var s = function (C, B) { var D = C[B]; if (D && typeof D === "object") { var n = null; for (var z in D) { if (b.call(D, z) && D !== C) { var y = s(D, z); if (y !== void 0) { D[z] = y } else { if (!n) { n = [] } n.push(z) } } } if (n) { for (var A = n.length; --A >= 0;) { delete D[n[A]] } } } return q.call(C, B, D) }; x = s({ "": x }, "") } return x } })();
/*! base64x-1.1.11 (c) 2012-2017 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
var KJUR; if (typeof KJUR == "undefined" || !KJUR) { KJUR = {} } if (typeof KJUR.lang == "undefined" || !KJUR.lang) { KJUR.lang = {} } KJUR.lang.String = function () { }; function Base64x() { } function stoBA(d) { var b = new Array(); for (var c = 0; c < d.length; c++) { b[c] = d.charCodeAt(c) } return b } function BAtos(b) { var d = ""; for (var c = 0; c < b.length; c++) { d = d + String.fromCharCode(b[c]) } return d } function BAtohex(b) { var e = ""; for (var d = 0; d < b.length; d++) { var c = b[d].toString(16); if (c.length == 1) { c = "0" + c } e = e + c } return e } function stohex(a) { return BAtohex(stoBA(a)) } function stob64(a) { return hex2b64(stohex(a)) } function stob64u(a) { return b64tob64u(hex2b64(stohex(a))) } function b64utos(a) { return BAtos(b64toBA(b64utob64(a))) } function b64tob64u(a) { a = a.replace(/\=/g, ""); a = a.replace(/\+/g, "-"); a = a.replace(/\//g, "_"); return a } function b64utob64(a) { if (a.length % 4 == 2) { a = a + "==" } else { if (a.length % 4 == 3) { a = a + "=" } } a = a.replace(/-/g, "+"); a = a.replace(/_/g, "/"); return a } function hextob64u(a) { if (a.length % 2 == 1) { a = "0" + a } return b64tob64u(hex2b64(a)) } function b64utohex(a) { return b64tohex(b64utob64(a)) } var utf8tob64u, b64utoutf8; if (typeof Buffer === "function") { utf8tob64u = function (a) { return b64tob64u(new Buffer(a, "utf8").toString("base64")) }; b64utoutf8 = function (a) { return new Buffer(b64utob64(a), "base64").toString("utf8") } } else { utf8tob64u = function (a) { return hextob64u(uricmptohex(encodeURIComponentAll(a))) }; b64utoutf8 = function (a) { return decodeURIComponent(hextouricmp(b64utohex(a))) } } function utf8tob64(a) { return hex2b64(uricmptohex(encodeURIComponentAll(a))) } function b64toutf8(a) { return decodeURIComponent(hextouricmp(b64tohex(a))) } function utf8tohex(a) { return uricmptohex(encodeURIComponentAll(a)) } function hextoutf8(a) { return decodeURIComponent(hextouricmp(a)) } function hextorstr(c) { var b = ""; for (var a = 0; a < c.length - 1; a += 2) { b += String.fromCharCode(parseInt(c.substr(a, 2), 16)) } return b } function rstrtohex(c) { var a = ""; for (var b = 0; b < c.length; b++) { a += ("0" + c.charCodeAt(b).toString(16)).slice(-2) } return a } function hextob64(a) { return hex2b64(a) } function hextob64nl(b) { var a = hextob64(b); var c = a.replace(/(.{64})/g, "$1\r\n"); c = c.replace(/\r\n$/, ""); return c } function b64nltohex(b) { var a = b.replace(/[^0-9A-Za-z\/+=]*/g, ""); var c = b64tohex(a); return c } function hextoArrayBuffer(d) { if (d.length % 2 != 0) { throw "input is not even length" } if (d.match(/^[0-9A-Fa-f]+$/) == null) { throw "input is not hexadecimal" } var b = new ArrayBuffer(d.length / 2); var a = new DataView(b); for (var c = 0; c < d.length / 2; c++) { a.setUint8(c, parseInt(d.substr(c * 2, 2), 16)) } return b } function ArrayBuffertohex(b) { var d = ""; var a = new DataView(b); for (var c = 0; c < b.byteLength; c++) { d += ("00" + a.getUint8(c).toString(16)).slice(-2) } return d } function zulutomsec(n) { var l, j, m, e, f, i, b, k; var a, h, g, c; c = n.match(/^(\d{2}|\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/); if (c) { a = c[1]; l = parseInt(a); if (a.length === 2) { if (50 <= l && l < 100) { l = 1900 + l } else { if (0 <= l && l < 50) { l = 2000 + l } } } j = parseInt(c[2]) - 1; m = parseInt(c[3]); e = parseInt(c[4]); f = parseInt(c[5]); i = parseInt(c[6]); b = 0; h = c[7]; if (h !== "") { g = (h.substr(1) + "00").substr(0, 3); b = parseInt(g) } return Date.UTC(l, j, m, e, f, i, b) } throw "unsupported zulu format: " + n } function zulutosec(a) { var b = zulutomsec(a); return ~~(b / 1000) } function zulutodate(a) { return new Date(zulutomsec(a)) } function datetozulu(g, e, f) { var b; var a = g.getUTCFullYear(); if (e) { if (a < 1950 || 2049 < a) { throw "not proper year for UTCTime: " + a } b = ("" + a).slice(-2) } else { b = ("000" + a).slice(-4) } b += ("0" + (g.getUTCMonth() + 1)).slice(-2); b += ("0" + g.getUTCDate()).slice(-2); b += ("0" + g.getUTCHours()).slice(-2); b += ("0" + g.getUTCMinutes()).slice(-2); b += ("0" + g.getUTCSeconds()).slice(-2); if (f) { var c = g.getUTCMilliseconds(); if (c !== 0) { c = ("00" + c).slice(-3); c = c.replace(/0+$/g, ""); b += "." + c } } b += "Z"; return b } function uricmptohex(a) { return a.replace(/%/g, "") } function hextouricmp(a) { return a.replace(/(..)/g, "%$1") } function encodeURIComponentAll(a) { var d = encodeURIComponent(a); var b = ""; for (var c = 0; c < d.length; c++) { if (d[c] == "%") { b = b + d.substr(c, 3); c = c + 2 } else { b = b + "%" + stohex(d[c]) } } return b } function newline_toUnix(a) { a = a.replace(/\r\n/mg, "\n"); return a } function newline_toDos(a) { a = a.replace(/\r\n/mg, "\n"); a = a.replace(/\n/mg, "\r\n"); return a } KJUR.lang.String.isInteger = function (a) { if (a.match(/^[0-9]+$/)) { return true } else { if (a.match(/^-[0-9]+$/)) { return true } else { return false } } }; KJUR.lang.String.isHex = function (a) { if (a.length % 2 == 0 && (a.match(/^[0-9a-f]+$/) || a.match(/^[0-9A-F]+$/))) { return true } else { return false } }; KJUR.lang.String.isBase64 = function (a) { a = a.replace(/\s+/g, ""); if (a.match(/^[0-9A-Za-z+\/]+={0,3}$/) && a.length % 4 == 0) { return true } else { return false } }; KJUR.lang.String.isBase64URL = function (a) { if (a.match(/[+/=]/)) { return false } a = b64utob64(a); return KJUR.lang.String.isBase64(a) }; KJUR.lang.String.isIntegerArray = function (a) { a = a.replace(/\s+/g, ""); if (a.match(/^\[[0-9,]+\]$/)) { return true } else { return false } }; function hextoposhex(a) { if (a.length % 2 == 1) { return "0" + a } if (a.substr(0, 1) > "7") { return "00" + a } return a } function intarystrtohex(b) { b = b.replace(/^\s*\[\s*/, ""); b = b.replace(/\s*\]\s*$/, ""); b = b.replace(/\s*/g, ""); try { var c = b.split(/,/).map(function (g, e, h) { var f = parseInt(g); if (f < 0 || 255 < f) { throw "integer not in range 0-255" } var d = ("00" + f.toString(16)).slice(-2); return d }).join(""); return c } catch (a) { throw "malformed integer array string: " + a } } var strdiffidx = function (c, a) { var d = c.length; if (c.length > a.length) { d = a.length } for (var b = 0; b < d; b++) { if (c.charCodeAt(b) != a.charCodeAt(b)) { return b } } if (c.length != a.length) { return d } return -1 };
/*! crypto-1.1.12.js (c) 2013-2017 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if (typeof KJUR == "undefined" || !KJUR) { KJUR = {} } if (typeof KJUR.crypto == "undefined" || !KJUR.crypto) { KJUR.crypto = {} } KJUR.crypto.Util = new function () { this.DIGESTINFOHEAD = { sha1: "3021300906052b0e03021a05000414", sha224: "302d300d06096086480165030402040500041c", sha256: "3031300d060960864801650304020105000420", sha384: "3041300d060960864801650304020205000430", sha512: "3051300d060960864801650304020305000440", md2: "3020300c06082a864886f70d020205000410", md5: "3020300c06082a864886f70d020505000410", ripemd160: "3021300906052b2403020105000414", }; this.DEFAULTPROVIDER = { md5: "cryptojs", sha1: "cryptojs", sha224: "cryptojs", sha256: "cryptojs", sha384: "cryptojs", sha512: "cryptojs", ripemd160: "cryptojs", hmacmd5: "cryptojs", hmacsha1: "cryptojs", hmacsha224: "cryptojs", hmacsha256: "cryptojs", hmacsha384: "cryptojs", hmacsha512: "cryptojs", hmacripemd160: "cryptojs", MD5withRSA: "cryptojs/jsrsa", SHA1withRSA: "cryptojs/jsrsa", SHA224withRSA: "cryptojs/jsrsa", SHA256withRSA: "cryptojs/jsrsa", SHA384withRSA: "cryptojs/jsrsa", SHA512withRSA: "cryptojs/jsrsa", RIPEMD160withRSA: "cryptojs/jsrsa", MD5withECDSA: "cryptojs/jsrsa", SHA1withECDSA: "cryptojs/jsrsa", SHA224withECDSA: "cryptojs/jsrsa", SHA256withECDSA: "cryptojs/jsrsa", SHA384withECDSA: "cryptojs/jsrsa", SHA512withECDSA: "cryptojs/jsrsa", RIPEMD160withECDSA: "cryptojs/jsrsa", SHA1withDSA: "cryptojs/jsrsa", SHA224withDSA: "cryptojs/jsrsa", SHA256withDSA: "cryptojs/jsrsa", MD5withRSAandMGF1: "cryptojs/jsrsa", SHA1withRSAandMGF1: "cryptojs/jsrsa", SHA224withRSAandMGF1: "cryptojs/jsrsa", SHA256withRSAandMGF1: "cryptojs/jsrsa", SHA384withRSAandMGF1: "cryptojs/jsrsa", SHA512withRSAandMGF1: "cryptojs/jsrsa", RIPEMD160withRSAandMGF1: "cryptojs/jsrsa", }; this.CRYPTOJSMESSAGEDIGESTNAME = { md5: CryptoJS.algo.MD5, sha1: CryptoJS.algo.SHA1, sha224: CryptoJS.algo.SHA224, sha256: CryptoJS.algo.SHA256, sha384: CryptoJS.algo.SHA384, sha512: CryptoJS.algo.SHA512, ripemd160: CryptoJS.algo.RIPEMD160 }; this.getDigestInfoHex = function (a, b) { if (typeof this.DIGESTINFOHEAD[b] == "undefined") { throw "alg not supported in Util.DIGESTINFOHEAD: " + b } return this.DIGESTINFOHEAD[b] + a }; this.getPaddedDigestInfoHex = function (h, a, j) { var c = this.getDigestInfoHex(h, a); var d = j / 4; if (c.length + 22 > d) { throw "key is too short for SigAlg: keylen=" + j + "," + a } var b = "0001"; var k = "00" + c; var g = ""; var l = d - b.length - k.length; for (var f = 0; f < l; f += 2) { g += "ff" } var e = b + g + k; return e }; this.hashString = function (a, c) { var b = new KJUR.crypto.MessageDigest({ alg: c }); return b.digestString(a) }; this.hashHex = function (b, c) { var a = new KJUR.crypto.MessageDigest({ alg: c }); return a.digestHex(b) }; this.sha1 = function (a) { var b = new KJUR.crypto.MessageDigest({ alg: "sha1", prov: "cryptojs" }); return b.digestString(a) }; this.sha256 = function (a) { var b = new KJUR.crypto.MessageDigest({ alg: "sha256", prov: "cryptojs" }); return b.digestString(a) }; this.sha256Hex = function (a) { var b = new KJUR.crypto.MessageDigest({ alg: "sha256", prov: "cryptojs" }); return b.digestHex(a) }; this.sha512 = function (a) { var b = new KJUR.crypto.MessageDigest({ alg: "sha512", prov: "cryptojs" }); return b.digestString(a) }; this.sha512Hex = function (a) { var b = new KJUR.crypto.MessageDigest({ alg: "sha512", prov: "cryptojs" }); return b.digestHex(a) } }; KJUR.crypto.Util.md5 = function (a) { var b = new KJUR.crypto.MessageDigest({ alg: "md5", prov: "cryptojs" }); return b.digestString(a) }; KJUR.crypto.Util.ripemd160 = function (a) { var b = new KJUR.crypto.MessageDigest({ alg: "ripemd160", prov: "cryptojs" }); return b.digestString(a) }; KJUR.crypto.Util.SECURERANDOMGEN = new SecureRandom(); KJUR.crypto.Util.getRandomHexOfNbytes = function (b) { var a = new Array(b); KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(a); return BAtohex(a) }; KJUR.crypto.Util.getRandomBigIntegerOfNbytes = function (a) { return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbytes(a), 16) }; KJUR.crypto.Util.getRandomHexOfNbits = function (d) { var c = d % 8; var a = (d - c) / 8; var b = new Array(a + 1); KJUR.crypto.Util.SECURERANDOMGEN.nextBytes(b); b[0] = (((255 << c) & 255) ^ 255) & b[0]; return BAtohex(b) }; KJUR.crypto.Util.getRandomBigIntegerOfNbits = function (a) { return new BigInteger(KJUR.crypto.Util.getRandomHexOfNbits(a), 16) }; KJUR.crypto.Util.getRandomBigIntegerZeroToMax = function (b) { var a = b.bitLength(); while (1) { var c = KJUR.crypto.Util.getRandomBigIntegerOfNbits(a); if (b.compareTo(c) != -1) { return c } } }; KJUR.crypto.Util.getRandomBigIntegerMinToMax = function (e, b) { var c = e.compareTo(b); if (c == 1) { throw "biMin is greater than biMax" } if (c == 0) { return e } var a = b.subtract(e); var d = KJUR.crypto.Util.getRandomBigIntegerZeroToMax(a); return d.add(e) }; KJUR.crypto.MessageDigest = function (c) { var b = null; var a = null; var d = null; this.setAlgAndProvider = function (g, f) { g = KJUR.crypto.MessageDigest.getCanonicalAlgName(g); if (g !== null && f === undefined) { f = KJUR.crypto.Util.DEFAULTPROVIDER[g] } if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g) != -1 && f == "cryptojs") { try { this.md = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g].create() } catch (e) { throw "setAlgAndProvider hash alg set fail alg=" + g + "/" + e } this.updateString = function (h) { this.md.update(h) }; this.updateHex = function (h) { var i = CryptoJS.enc.Hex.parse(h); this.md.update(i) }; this.digest = function () { var h = this.md.finalize(); return h.toString(CryptoJS.enc.Hex) }; this.digestString = function (h) { this.updateString(h); return this.digest() }; this.digestHex = function (h) { this.updateHex(h); return this.digest() } } if (":sha256:".indexOf(g) != -1 && f == "sjcl") { try { this.md = new sjcl.hash.sha256() } catch (e) { throw "setAlgAndProvider hash alg set fail alg=" + g + "/" + e } this.updateString = function (h) { this.md.update(h) }; this.updateHex = function (i) { var h = sjcl.codec.hex.toBits(i); this.md.update(h) }; this.digest = function () { var h = this.md.finalize(); return sjcl.codec.hex.fromBits(h) }; this.digestString = function (h) { this.updateString(h); return this.digest() }; this.digestHex = function (h) { this.updateHex(h); return this.digest() } } }; this.updateString = function (e) { throw "updateString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName }; this.updateHex = function (e) { throw "updateHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName }; this.digest = function () { throw "digest() not supported for this alg/prov: " + this.algName + "/" + this.provName }; this.digestString = function (e) { throw "digestString(str) not supported for this alg/prov: " + this.algName + "/" + this.provName }; this.digestHex = function (e) { throw "digestHex(hex) not supported for this alg/prov: " + this.algName + "/" + this.provName }; if (c !== undefined) { if (c.alg !== undefined) { this.algName = c.alg; if (c.prov === undefined) { this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName] } this.setAlgAndProvider(this.algName, this.provName) } } }; KJUR.crypto.MessageDigest.getCanonicalAlgName = function (a) { if (typeof a === "string") { a = a.toLowerCase(); a = a.replace(/-/, "") } return a }; KJUR.crypto.MessageDigest.getHashLength = function (c) { var b = KJUR.crypto.MessageDigest; var a = b.getCanonicalAlgName(c); if (b.HASHLENGTH[a] === undefined) { throw "not supported algorithm: " + c } return b.HASHLENGTH[a] }; KJUR.crypto.MessageDigest.HASHLENGTH = { md5: 16, sha1: 20, sha224: 28, sha256: 32, sha384: 48, sha512: 64, ripemd160: 20 }; KJUR.crypto.Mac = function (d) { var f = null; var c = null; var a = null; var e = null; var b = null; this.setAlgAndProvider = function (k, i) { k = k.toLowerCase(); if (k == null) { k = "hmacsha1" } k = k.toLowerCase(); if (k.substr(0, 4) != "hmac") { throw "setAlgAndProvider unsupported HMAC alg: " + k } if (i === undefined) { i = KJUR.crypto.Util.DEFAULTPROVIDER[k] } this.algProv = k + "/" + i; var g = k.substr(4); if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(g) != -1 && i == "cryptojs") { try { var j = KJUR.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[g]; this.mac = CryptoJS.algo.HMAC.create(j, this.pass) } catch (h) { throw "setAlgAndProvider hash alg set fail hashAlg=" + g + "/" + h } this.updateString = function (l) { this.mac.update(l) }; this.updateHex = function (l) { var m = CryptoJS.enc.Hex.parse(l); this.mac.update(m) }; this.doFinal = function () { var l = this.mac.finalize(); return l.toString(CryptoJS.enc.Hex) }; this.doFinalString = function (l) { this.updateString(l); return this.doFinal() }; this.doFinalHex = function (l) { this.updateHex(l); return this.doFinal() } } }; this.updateString = function (g) { throw "updateString(str) not supported for this alg/prov: " + this.algProv }; this.updateHex = function (g) { throw "updateHex(hex) not supported for this alg/prov: " + this.algProv }; this.doFinal = function () { throw "digest() not supported for this alg/prov: " + this.algProv }; this.doFinalString = function (g) { throw "digestString(str) not supported for this alg/prov: " + this.algProv }; this.doFinalHex = function (g) { throw "digestHex(hex) not supported for this alg/prov: " + this.algProv }; this.setPassword = function (h) { if (typeof h == "string") { var g = h; if (h.length % 2 == 1 || !h.match(/^[0-9A-Fa-f]+$/)) { g = rstrtohex(h) } this.pass = CryptoJS.enc.Hex.parse(g); return } if (typeof h != "object") { throw "KJUR.crypto.Mac unsupported password type: " + h } var g = null; if (h.hex !== undefined) { if (h.hex.length % 2 != 0 || !h.hex.match(/^[0-9A-Fa-f]+$/)) { throw "Mac: wrong hex password: " + h.hex } g = h.hex } if (h.utf8 !== undefined) { g = utf8tohex(h.utf8) } if (h.rstr !== undefined) { g = rstrtohex(h.rstr) } if (h.b64 !== undefined) { g = b64tohex(h.b64) } if (h.b64u !== undefined) { g = b64utohex(h.b64u) } if (g == null) { throw "KJUR.crypto.Mac unsupported password type: " + h } this.pass = CryptoJS.enc.Hex.parse(g) }; if (d !== undefined) { if (d.pass !== undefined) { this.setPassword(d.pass) } if (d.alg !== undefined) { this.algName = d.alg; if (d.prov === undefined) { this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName] } this.setAlgAndProvider(this.algName, this.provName) } } }; KJUR.crypto.Signature = function (o) { var q = null; var n = null; var r = null; var c = null; var l = null; var d = null; var k = null; var h = null; var p = null; var e = null; var b = -1; var g = null; var j = null; var a = null; var i = null; var f = null; this._setAlgNames = function () { var s = this.algName.match(/^(.+)with(.+)$/); if (s) { this.mdAlgName = s[1].toLowerCase(); this.pubkeyAlgName = s[2].toLowerCase() } }; this._zeroPaddingOfSignature = function (x, w) { var v = ""; var t = w / 4 - x.length; for (var u = 0; u < t; u++) { v = v + "0" } return v + x }; this.setAlgAndProvider = function (u, t) { this._setAlgNames(); if (t != "cryptojs/jsrsa") { throw "provider not supported: " + t } if (":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName) != -1) { try { this.md = new KJUR.crypto.MessageDigest({ alg: this.mdAlgName }) } catch (s) { throw "setAlgAndProvider hash alg set fail alg=" + this.mdAlgName + "/" + s } this.init = function (w, x) { var y = null; try { if (x === undefined) { y = KEYUTIL.getKey(w) } else { y = KEYUTIL.getKey(w, x) } } catch (v) { throw "init failed:" + v } if (y.isPrivate === true) { this.prvKey = y; this.state = "SIGN" } else { if (y.isPublic === true) { this.pubKey = y; this.state = "VERIFY" } else { throw "init failed.:" + y } } }; this.initSign = function (v) { if (typeof v.ecprvhex == "string" && typeof v.eccurvename == "string") { this.ecprvhex = v.ecprvhex; this.eccurvename = v.eccurvename } else { this.prvKey = v } this.state = "SIGN" }; this.initVerifyByPublicKey = function (v) { if (typeof v.ecpubhex == "string" && typeof v.eccurvename == "string") { this.ecpubhex = v.ecpubhex; this.eccurvename = v.eccurvename } else { if (v instanceof KJUR.crypto.ECDSA) { this.pubKey = v } else { if (v instanceof RSAKey) { this.pubKey = v } } } this.state = "VERIFY" }; this.initVerifyByCertificatePEM = function (v) { var w = new X509(); w.readCertPEM(v); this.pubKey = w.subjectPublicKeyRSA; this.state = "VERIFY" }; this.updateString = function (v) { this.md.updateString(v) }; this.updateHex = function (v) { this.md.updateHex(v) }; this.sign = function () { this.sHashHex = this.md.digest(); if (typeof this.ecprvhex != "undefined" && typeof this.eccurvename != "undefined") { var v = new KJUR.crypto.ECDSA({ curve: this.eccurvename }); this.hSign = v.signHex(this.sHashHex, this.ecprvhex) } else { if (this.prvKey instanceof RSAKey && this.pubkeyAlgName == "rsaandmgf1") { this.hSign = this.prvKey.signWithMessageHashPSS(this.sHashHex, this.mdAlgName, this.pssSaltLen) } else { if (this.prvKey instanceof RSAKey && this.pubkeyAlgName == "rsa") { this.hSign = this.prvKey.signWithMessageHash(this.sHashHex, this.mdAlgName) } else { if (this.prvKey instanceof KJUR.crypto.ECDSA) { this.hSign = this.prvKey.signWithMessageHash(this.sHashHex) } else { if (this.prvKey instanceof KJUR.crypto.DSA) { this.hSign = this.prvKey.signWithMessageHash(this.sHashHex) } else { throw "Signature: unsupported public key alg: " + this.pubkeyAlgName } } } } } return this.hSign }; this.signString = function (v) { this.updateString(v); return this.sign() }; this.signHex = function (v) { this.updateHex(v); return this.sign() }; this.verify = function (v) { this.sHashHex = this.md.digest(); if (typeof this.ecpubhex != "undefined" && typeof this.eccurvename != "undefined") { var w = new KJUR.crypto.ECDSA({ curve: this.eccurvename }); return w.verifyHex(this.sHashHex, v, this.ecpubhex) } else { if (this.pubKey instanceof RSAKey && this.pubkeyAlgName == "rsaandmgf1") { return this.pubKey.verifyWithMessageHashPSS(this.sHashHex, v, this.mdAlgName, this.pssSaltLen) } else { if (this.pubKey instanceof RSAKey && this.pubkeyAlgName == "rsa") { return this.pubKey.verifyWithMessageHash(this.sHashHex, v) } else { if (this.pubKey instanceof KJUR.crypto.ECDSA) { return this.pubKey.verifyWithMessageHash(this.sHashHex, v) } else { if (this.pubKey instanceof KJUR.crypto.DSA) { return this.pubKey.verifyWithMessageHash(this.sHashHex, v) } else { throw "Signature: unsupported public key alg: " + this.pubkeyAlgName } } } } } } } }; this.init = function (s, t) { throw "init(key, pass) not supported for this alg:prov=" + this.algProvName }; this.initVerifyByPublicKey = function (s) { throw "initVerifyByPublicKey(rsaPubKeyy) not supported for this alg:prov=" + this.algProvName }; this.initVerifyByCertificatePEM = function (s) { throw "initVerifyByCertificatePEM(certPEM) not supported for this alg:prov=" + this.algProvName }; this.initSign = function (s) { throw "initSign(prvKey) not supported for this alg:prov=" + this.algProvName }; this.updateString = function (s) { throw "updateString(str) not supported for this alg:prov=" + this.algProvName }; this.updateHex = function (s) { throw "updateHex(hex) not supported for this alg:prov=" + this.algProvName }; this.sign = function () { throw "sign() not supported for this alg:prov=" + this.algProvName }; this.signString = function (s) { throw "digestString(str) not supported for this alg:prov=" + this.algProvName }; this.signHex = function (s) { throw "digestHex(hex) not supported for this alg:prov=" + this.algProvName }; this.verify = function (s) { throw "verify(hSigVal) not supported for this alg:prov=" + this.algProvName }; this.initParams = o; if (o !== undefined) { if (o.alg !== undefined) { this.algName = o.alg; if (o.prov === undefined) { this.provName = KJUR.crypto.Util.DEFAULTPROVIDER[this.algName] } else { this.provName = o.prov } this.algProvName = this.algName + ":" + this.provName; this.setAlgAndProvider(this.algName, this.provName); this._setAlgNames() } if (o.psssaltlen !== undefined) { this.pssSaltLen = o.psssaltlen } if (o.prvkeypem !== undefined) { if (o.prvkeypas !== undefined) { throw "both prvkeypem and prvkeypas parameters not supported" } else { try { var q = new RSAKey(); q.readPrivateKeyFromPEMString(o.prvkeypem); this.initSign(q) } catch (m) { throw "fatal error to load pem private key: " + m } } } } }; KJUR.crypto.Cipher = function (a) { }; KJUR.crypto.Cipher.encrypt = function (e, f, d) { if (f instanceof RSAKey && f.isPublic) { var c = KJUR.crypto.Cipher.getAlgByKeyAndName(f, d); if (c === "RSA") { return f.encrypt(e) } if (c === "RSAOAEP") { return f.encryptOAEP(e, "sha1") } var b = c.match(/^RSAOAEP(\d+)$/); if (b !== null) { return f.encryptOAEP(e, "sha" + b[1]) } throw "Cipher.encrypt: unsupported algorithm for RSAKey: " + d } else { throw "Cipher.encrypt: unsupported key or algorithm" } }; KJUR.crypto.Cipher.decrypt = function (e, f, d) { if (f instanceof RSAKey && f.isPrivate) { var c = KJUR.crypto.Cipher.getAlgByKeyAndName(f, d); if (c === "RSA") { return f.decrypt(e) } if (c === "RSAOAEP") { return f.decryptOAEP(e, "sha1") } var b = c.match(/^RSAOAEP(\d+)$/); if (b !== null) { return f.decryptOAEP(e, "sha" + b[1]) } throw "Cipher.decrypt: unsupported algorithm for RSAKey: " + d } else { throw "Cipher.decrypt: unsupported key or algorithm" } }; KJUR.crypto.Cipher.getAlgByKeyAndName = function (b, a) { if (b instanceof RSAKey) { if (":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(a) != -1) { return a } if (a === null || a === undefined) { return "RSA" } throw "getAlgByKeyAndName: not supported algorithm name for RSAKey: " + a } throw "getAlgByKeyAndName: not supported algorithm name: " + a }; KJUR.crypto.OID = new function () { this.oidhex2name = { "2a864886f70d010101": "rsaEncryption", "2a8648ce3d0201": "ecPublicKey", "2a8648ce380401": "dsa", "2a8648ce3d030107": "secp256r1", "2b8104001f": "secp192k1", "2b81040021": "secp224r1", "2b8104000a": "secp256k1", "2b81040023": "secp521r1", "2b81040022": "secp384r1", "2a8648ce380403": "SHA1withDSA", "608648016503040301": "SHA224withDSA", "608648016503040302": "SHA256withDSA", } };
/*! jws-3.3.6 (c) 2013-2017 Kenji Urushima | kjur.github.com/jsrsasign/license
 */
if (typeof KJUR == "undefined" || !KJUR) { KJUR = {} } if (typeof KJUR.jws == "undefined" || !KJUR.jws) { KJUR.jws = {} } KJUR.jws.JWS = function () { var a = KJUR.jws.JWS; this.parseJWS = function (e, h) { if ((this.parsedJWS !== undefined) && (h || (this.parsedJWS.sigvalH !== undefined))) { return } var g = e.match(/^([^.]+)\.([^.]+)\.([^.]+)$/); if (g == null) { throw "JWS signature is not a form of 'Head.Payload.SigValue'." } var i = g[1]; var c = g[2]; var j = g[3]; var l = i + "." + c; this.parsedJWS = {}; this.parsedJWS.headB64U = i; this.parsedJWS.payloadB64U = c; this.parsedJWS.sigvalB64U = j; this.parsedJWS.si = l; if (!h) { var f = b64utohex(j); var d = parseBigInt(f, 16); this.parsedJWS.sigvalH = f; this.parsedJWS.sigvalBI = d } var b = b64utoutf8(i); var k = b64utoutf8(c); this.parsedJWS.headS = b; this.parsedJWS.payloadS = k; if (!a.isSafeJSONString(b, this.parsedJWS, "headP")) { throw "malformed JSON string for JWS Head: " + b } } }; KJUR.jws.JWS.sign = function (a, i, c, m, l) { var k = KJUR.jws.JWS; var q, e, j; if (typeof i != "string" && typeof i != "object") { throw "spHeader must be JSON string or object: " + i } if (typeof i == "object") { e = i; q = JSON.stringify(e) } if (typeof i == "string") { q = i; if (!k.isSafeJSONString(q)) { throw "JWS Head is not safe JSON string: " + q } e = k.readSafeJSONString(q) } j = c; if (typeof c == "object") { j = JSON.stringify(c) } if ((a == "" || a == null) && e.alg !== undefined) { a = e.alg } if ((a != "" && a != null) && e.alg === undefined) { e.alg = a; q = JSON.stringify(e) } if (a !== e.alg) { throw "alg and sHeader.alg doesn't match: " + a + "!=" + e.alg } var d = null; if (k.jwsalg2sigalg[a] === undefined) { throw "unsupported alg name: " + a } else { d = k.jwsalg2sigalg[a] } var b = utf8tob64u(q); var g = utf8tob64u(j); var o = b + "." + g; var n = ""; if (d.substr(0, 4) == "Hmac") { if (m === undefined) { throw "mac key shall be specified for HS* alg" } var h = new KJUR.crypto.Mac({ alg: d, prov: "cryptojs", pass: m }); h.updateString(o); n = h.doFinal() } else { if (d.indexOf("withECDSA") != -1) { var p = new KJUR.crypto.Signature({ alg: d }); p.init(m, l); p.updateString(o); hASN1Sig = p.sign(); n = KJUR.crypto.ECDSA.asn1SigToConcatSig(hASN1Sig) } else { if (d != "none") { var p = new KJUR.crypto.Signature({ alg: d }); p.init(m, l); p.updateString(o); n = p.sign() } } } var f = hextob64u(n); return o + "." + f }; KJUR.jws.JWS.verify = function (p, t, j) { var m = KJUR.jws.JWS; var q = p.split("."); var d = q[0]; var l = q[1]; var b = d + "." + l; var r = b64utohex(q[2]); var i = m.readSafeJSONString(b64utoutf8(q[0])); var h = null; var s = null; if (i.alg === undefined) { throw "algorithm not specified in header" } else { h = i.alg; s = h.substr(0, 2) } if (j != null && Object.prototype.toString.call(j) === "[object Array]" && j.length > 0) { var c = ":" + j.join(":") + ":"; if (c.indexOf(":" + h + ":") == -1) { throw "algorithm '" + h + "' not accepted in the list" } } if (h != "none" && t === null) { throw "key shall be specified to verify." } if (typeof t == "string" && t.indexOf("-----BEGIN ") != -1) { t = KEYUTIL.getKey(t) } if (s == "RS" || s == "PS") { if (!(t instanceof RSAKey)) { throw "key shall be a RSAKey obj for RS* and PS* algs" } } if (s == "ES") { if (!(t instanceof KJUR.crypto.ECDSA)) { throw "key shall be a ECDSA obj for ES* algs" } } if (h == "none") { } var n = null; if (m.jwsalg2sigalg[i.alg] === undefined) { throw "unsupported alg name: " + h } else { n = m.jwsalg2sigalg[h] } if (n == "none") { throw "not supported" } else { if (n.substr(0, 4) == "Hmac") { var k = null; if (t === undefined) { throw "hexadecimal key shall be specified for HMAC" } var g = new KJUR.crypto.Mac({ alg: n, pass: t }); g.updateString(b); k = g.doFinal(); return r == k } else { if (n.indexOf("withECDSA") != -1) { var f = null; try { f = KJUR.crypto.ECDSA.concatSigToASN1Sig(r) } catch (o) { return false } var e = new KJUR.crypto.Signature({ alg: n }); e.init(t); e.updateString(b); return e.verify(f) } else { var e = new KJUR.crypto.Signature({ alg: n }); e.init(t); e.updateString(b); return e.verify(r) } } } }; KJUR.jws.JWS.parse = function (g) { var c = g.split("."); var b = {}; var f, e, d; if (c.length != 2 && c.length != 3) { throw "malformed sJWS: wrong number of '.' splitted elements" } f = c[0]; e = c[1]; if (c.length == 3) { d = c[2] } b.headerObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(f)); b.payloadObj = KJUR.jws.JWS.readSafeJSONString(b64utoutf8(e)); b.headerPP = JSON.stringify(b.headerObj, null, "  "); if (b.payloadObj == null) { b.payloadPP = b64utoutf8(e) } else { b.payloadPP = JSON.stringify(b.payloadObj, null, "  ") } if (d !== undefined) { b.sigHex = b64utohex(d) } return b }; KJUR.jws.JWS.verifyJWT = function (d, j, l) { var h = KJUR.jws.JWS; var i = d.split("."); var c = i[0]; var g = i[1]; var m = c + "." + g; var k = b64utohex(i[2]); var f = h.readSafeJSONString(b64utoutf8(c)); var e = h.readSafeJSONString(b64utoutf8(g)); if (f.alg === undefined) { return false } if (l.alg === undefined) { throw "acceptField.alg shall be specified" } if (!h.inArray(f.alg, l.alg)) { return false } if (e.iss !== undefined && typeof l.iss === "object") { if (!h.inArray(e.iss, l.iss)) { return false } } if (e.sub !== undefined && typeof l.sub === "object") { if (!h.inArray(e.sub, l.sub)) { return false } } if (e.aud !== undefined && typeof l.aud === "object") { if (typeof e.aud == "string") { if (!h.inArray(e.aud, l.aud)) { return false } } else { if (typeof e.aud == "object") { if (!h.includedArray(e.aud, l.aud)) { return false } } } } var b = KJUR.jws.IntDate.getNow(); if (l.verifyAt !== undefined && typeof l.verifyAt === "number") { b = l.verifyAt } if (l.gracePeriod === undefined || typeof l.gracePeriod !== "number") { l.gracePeriod = 0 } if (e.exp !== undefined && typeof e.exp == "number") { if (e.exp + l.gracePeriod < b) { return false } } if (e.nbf !== undefined && typeof e.nbf == "number") { if (b < e.nbf - l.gracePeriod) { return false } } if (e.iat !== undefined && typeof e.iat == "number") { if (b < e.iat - l.gracePeriod) { return false } } if (e.jti !== undefined && l.jti !== undefined) { if (e.jti !== l.jti) { return false } } if (!KJUR.jws.JWS.verify(d, j, l.alg)) { return false } return true }; KJUR.jws.JWS.includedArray = function (b, a) { var d = KJUR.jws.JWS.inArray; if (b === null) { return false } if (typeof b !== "object") { return false } if (typeof b.length !== "number") { return false } for (var c = 0; c < b.length; c++) { if (!d(b[c], a)) { return false } } return true }; KJUR.jws.JWS.inArray = function (d, b) { if (b === null) { return false } if (typeof b !== "object") { return false } if (typeof b.length !== "number") { return false } for (var c = 0; c < b.length; c++) { if (b[c] == d) { return true } } return false }; KJUR.jws.JWS.jwsalg2sigalg = { HS256: "HmacSHA256", HS384: "HmacSHA384", HS512: "HmacSHA512", RS256: "SHA256withRSA", RS384: "SHA384withRSA", RS512: "SHA512withRSA", ES256: "SHA256withECDSA", ES384: "SHA384withECDSA", PS256: "SHA256withRSAandMGF1", PS384: "SHA384withRSAandMGF1", PS512: "SHA512withRSAandMGF1", none: "none", }; KJUR.jws.JWS.isSafeJSONString = function (c, b, d) { var e = null; try { e = jsonParse(c); if (typeof e != "object") { return 0 } if (e.constructor === Array) { return 0 } if (b) { b[d] = e } return 1 } catch (a) { return 0 } }; KJUR.jws.JWS.readSafeJSONString = function (b) { var c = null; try { c = jsonParse(b); if (typeof c != "object") { return null } if (c.constructor === Array) { return null } return c } catch (a) { return null } }; KJUR.jws.JWS.getEncodedSignatureValueFromJWS = function (b) { var a = b.match(/^[^.]+\.[^.]+\.([^.]+)$/); if (a == null) { throw "JWS signature is not a form of 'Head.Payload.SigValue'." } return a[1] }; KJUR.jws.JWS.getJWKthumbprint = function (d) { if (d.kty !== "RSA" && d.kty !== "EC" && d.kty !== "oct") { throw "unsupported algorithm for JWK Thumprint" } var a = "{"; if (d.kty === "RSA") { if (typeof d.n != "string" || typeof d.e != "string") { throw "wrong n and e value for RSA key" } a += '"e":"' + d.e + '",'; a += '"kty":"' + d.kty + '",'; a += '"n":"' + d.n + '"}' } else { if (d.kty === "EC") { if (typeof d.crv != "string" || typeof d.x != "string" || typeof d.y != "string") { throw "wrong crv, x and y value for EC key" } a += '"crv":"' + d.crv + '",'; a += '"kty":"' + d.kty + '",'; a += '"x":"' + d.x + '",'; a += '"y":"' + d.y + '"}' } else { if (d.kty === "oct") { if (typeof d.k != "string") { throw "wrong k value for oct(symmetric) key" } a += '"kty":"' + d.kty + '",'; a += '"k":"' + d.k + '"}' } } } var b = rstrtohex(a); var c = KJUR.crypto.Util.hashHex(b, "sha256"); var e = hextob64u(c); return e }; KJUR.jws.IntDate = {}; KJUR.jws.IntDate.get = function (a) { if (a == "now") { return KJUR.jws.IntDate.getNow() } else { if (a == "now + 1hour") { return KJUR.jws.IntDate.getNow() + 60 * 60 } else { if (a == "now + 1day") { return KJUR.jws.IntDate.getNow() + 60 * 60 * 24 } else { if (a == "now + 1month") { return KJUR.jws.IntDate.getNow() + 60 * 60 * 24 * 30 } else { if (a == "now + 1year") { return KJUR.jws.IntDate.getNow() + 60 * 60 * 24 * 365 } else { if (a.match(/Z$/)) { return KJUR.jws.IntDate.getZulu(a) } else { if (a.match(/^[0-9]+$/)) { return parseInt(a) } } } } } } } throw "unsupported format: " + a }; KJUR.jws.IntDate.getZulu = function (a) { return zulutosec(a) }; KJUR.jws.IntDate.getNow = function () { var a = ~~(new Date() / 1000); return a }; KJUR.jws.IntDate.intDate2UTCString = function (a) { var b = new Date(a * 1000); return b.toUTCString() }; KJUR.jws.IntDate.intDate2Zulu = function (e) { var i = new Date(e * 1000); var h = ("0000" + i.getUTCFullYear()).slice(-4); var g = ("00" + (i.getUTCMonth() + 1)).slice(-2); var b = ("00" + i.getUTCDate()).slice(-2); var a = ("00" + i.getUTCHours()).slice(-2); var c = ("00" + i.getUTCMinutes()).slice(-2); var f = ("00" + i.getUTCSeconds()).slice(-2); return h + g + b + a + c + f + "Z" };
// From: https://jwt.io/js/jwt.js

; (function () {

	var object =
		typeof exports != 'undefined' ? exports :
			typeof self != 'undefined' ? self : // #8: web workers
				$.global; // #31: ExtendScript

	var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	function InvalidCharacterError(message) {
		this.message = message;
	}
	InvalidCharacterError.prototype = new Error;
	InvalidCharacterError.prototype.name = 'InvalidCharacterError';

	// encoder
	// [https://gist.github.com/999166] by [https://github.com/nignag]
	object.btoa || (
		object.btoa = function (input) {
			var str = String(input);
			for (
				// initialize result and counter
				var block, charCode, idx = 0, map = chars, output = '';
				// if the next str index does not exist:
				//   change the mapping table to "="
				//   check if d has no fractional digits
				str.charAt(idx | 0) || (map = '=', idx % 1);
				// "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
				output += map.charAt(63 & block >> 8 - idx % 1 * 8)
			) {
				charCode = str.charCodeAt(idx += 3 / 4);
				if (charCode > 0xFF) {
					throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
				}
				block = block << 8 | charCode;
			}
			return output;
		});

	// decoder
	// [https://gist.github.com/1020396] by [https://github.com/atk]
	(
		object.atob = function (input) {
			var str = String(input).replace(/[=]+$/, ''); // #31: ExtendScript bad parse of /=
			if (str.length % 4 == 1) {
				throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
			}
			for (
				// initialize result and counters
				var bc = 0, bs, buffer, idx = 0, output = '';
				// get next character
				buffer = str.charAt(idx++);
				// character found in table? initialize bit storage and add its ascii value;
				~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
					// and if not first of each 4 characters,
					// convert the first 8 bits to one ascii character
					bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
			) {
				// try to find character in table (0-63, not found => -1)
				buffer = chars.indexOf(buffer);
			}
			return output;
		});

}());


// XXX Hack to prevent hextorstr function used by JWS send a string instead of
// a Word Array. On this way, no string decoding needs to take place and Crypto
// takes care of everything.
// Note that it should not affect the other algorithms as hextorstr is exclusively
// used on Hmac family (that invokes CryptoJS library).
window.hextorstr = function (c) {
	return window.CryptoJS.enc.Hex.parse(c);
};


//this is used to parse base64
function url_base64_decode(str) {
	var output = str.replace(/-/g, '+').replace(/_/g, '/');
	switch (output.length % 4) {
		case 0:
			break;
		case 2:
			output += '==';
			break;
		case 3:
			output += '=';
			break;
		default:
			throw 'Illegal base64url string!';
	}
	var result = window.atob(output); //polifyll https://github.com/davidchambers/Base64.js
	try {
		return decodeURIComponent(escape(result));
	} catch (err) {
		return result;
	}
}

window.decode = function (base64json) {
	var json = null, error = null;
	try {
		json = url_base64_decode(base64json);
		json = JSON.stringify(JSON.parse(json), undefined, 2);
	} catch (e) {
		error = e;
	}
	return { result: json, error: error };
};

window.sign = function (algorithm, header, payload, key, isSecretBase64Encoded) {
	var value = '', error = null, headerAsJSON, payloadAsJSON;

	try {
		headerAsJSON = JSON.stringify(JSON.parse(header));
	} catch (e) {
		error = { result: null, error: { cause: e, who: ['header'] } };
	}
	try {
		payloadAsJSON = JSON.stringify(JSON.parse(payload));
	} catch (e) {
		if (error) {
			error.error.who.push('payload');
		} else {
			error = { result: null, error: { cause: e, who: ['payload'] } };
		}
	}

	if (error) {
		return error;
	}

	if (algorithm === 'HS256') {
		if (isSecretBase64Encoded) {
			try {
				key = window.b64utob64(key);
				key = window.CryptoJS.enc.Base64.parse(key).toString();
			} catch (e) {
				return { result: '', error: e };
			}
		} else {
			key = window.CryptoJS.enc.Latin1.parse(key).toString();
		}
	}

	try {
		value = KJUR.jws.JWS.sign(algorithm, headerAsJSON, payloadAsJSON, key);
	} catch (e) {
		error = e;
	}

	return { result: value, error: error };
};

window.isValidBase64String = function (s) {
	try {
		s = window.b64utob64(s);
		window.CryptoJS.enc.Base64.parse(s).toString();
		return true;
	} catch (e) {
		return false;
	}
};

window.verify = function (algorithm, value, key, isSecretBase64Encoded) {

	var result = '', error = null;

	if (algorithm === 'HS256') {
		if (isSecretBase64Encoded) {
			try {
				key = window.b64utob64(key);
				key = window.CryptoJS.enc.Base64.parse(key).toString();
			} catch (e) {
				return { result: '', error: e };
			}
		} else {
			key = window.CryptoJS.enc.Latin1.parse(key).toString();
		}
	}

	try {
		result = KJUR.jws.JWS.verify(value, key);
	} catch (e) {
		error = e;
	}

	return { result: result, error: error };
};
/*eslint-env es6:false*/
/*
 * Copyright (c) 2010 Arc90 Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * This code is heavily based on Arc90's readability.js (1.7.1) script
 * available at: http://code.google.com/p/arc90labs-readability
 */

/**
 * Public constructor.
 * @param {HTMLDocument} doc     The document to parse.
 * @param {Object}       options The options object.
 */
function Readability(doc, options) {
	// In some older versions, people passed a URI object as the first argument. Cope:
	if (doc && !doc.documentElement && doc.spec) {
		doc = options;
		options = arguments[2];
	}
	options = options || {};

	this._doc = doc;
	this._articleTitle = null;
	this._articleByline = null;
	this._articleDir = null;
	this._attempts = [];

	// Configurable options
	this._debug = !!options.debug;
	this._maxElemsToParse = options.maxElemsToParse || this.DEFAULT_MAX_ELEMS_TO_PARSE;
	this._nbTopCandidates = options.nbTopCandidates || this.DEFAULT_N_TOP_CANDIDATES;
	this._charThreshold = options.charThreshold || this.DEFAULT_CHAR_THRESHOLD;
	this._classesToPreserve = this.CLASSES_TO_PRESERVE.concat(options.classesToPreserve || []);

	// Start with all flags set
	this._flags = this.FLAG_STRIP_UNLIKELYS |
		this.FLAG_WEIGHT_CLASSES |
		this.FLAG_CLEAN_CONDITIONALLY;

	var logEl;

	// Control whether log messages are sent to the console
	if (this._debug) {
		logEl = function (e) {
			var rv = e.nodeName + " ";
			if (e.nodeType == e.TEXT_NODE) {
				return rv + '("' + e.textContent + '")';
			}
			var classDesc = e.className && ("." + e.className.replace(/ /g, "."));
			var elDesc = "";
			if (e.id)
				elDesc = "(#" + e.id + classDesc + ")";
			else if (classDesc)
				elDesc = "(" + classDesc + ")";
			return rv + elDesc;
		};
		this.log = function () {
			if (typeof dump !== "undefined") {
				var msg = Array.prototype.map.call(arguments, function (x) {
					return (x && x.nodeName) ? logEl(x) : x;
				}).join(" ");
				dump("Reader: (Readability) " + msg + "\n");
			} else if (typeof console !== "undefined") {
				var args = ["Reader: (Readability) "].concat(arguments);
				console.log.apply(console, args);
			}
		};
	} else {
		this.log = function () { };
	}
}

Readability.prototype = {
	FLAG_STRIP_UNLIKELYS: 0x1,
	FLAG_WEIGHT_CLASSES: 0x2,
	FLAG_CLEAN_CONDITIONALLY: 0x4,

	// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
	ELEMENT_NODE: 1,
	TEXT_NODE: 3,

	// Max number of nodes supported by this parser. Default: 0 (no limit)
	DEFAULT_MAX_ELEMS_TO_PARSE: 0,

	// The number of top candidates to consider when analysing how
	// tight the competition is among candidates.
	DEFAULT_N_TOP_CANDIDATES: 5,

	// Element tags to score by default.
	DEFAULT_TAGS_TO_SCORE: "section,h2,h3,h4,h5,h6,p,td,pre".toUpperCase().split(","),

	// The default number of chars an article must have in order to return a result
	DEFAULT_CHAR_THRESHOLD: 250,

	// All of the regular expressions in use within readability.
	// Defined up here so we don't instantiate them repeatedly in loops.
	REGEXPS: {
		unlikelyCandidates: /banner|breadcrumbs|combx|comment|community|cover-wrap|disqus|extra|foot|header|legends|menu|related|remark|replies|rss|shoutbox|sidebar|skyscraper|social|sponsor|supplemental|ad-break|agegate|pagination|pager|popup|yom-remote|flash|js|el__featured-video|meta|kicker-label|headline|page-title/i,
		okMaybeItsACandidate: /and|article|body|column|main|shadow|continues|postContent|content|story-content|story-body-supplemental|story-continues|story-continues-2|el__leafmedia-speakble-paragraph|morning-briefing/i,
		positive: /article|body|content|entry|hentry|h-entry|main|page|pagination|post|text|blog|story|postContent|story-body|story-body-text|story-content|articleBody|/i,
		negative: /hidden|^hid$| hid$| hid |^hid |banner|combx|comment|com-|contact|foot|footer|footnote|masthead|media|meta|outbrain|taboola|promo|related|scroll|share|shoutbox|sidebar|skyscraper|sponsor|shopping|tags|tool|widget|flash-state|video__end-slate--interactive|js|zn-large-media|script|fav|unmute|el__video__collection__close-expandable|headline/i,
		extraneous: /print|archive|comment|discuss|e[\-]?mail|share|reply|all|login|sign|single|utility/i,
		byline: /byline|author|dateline|writtenby|p-author|name/i,
		replaceFonts: /<(\/?)font[^>]*>/gi,
		normalize: /\s{2,}/g,
		videos: /\/\/(www\.)?(dailymotion|youtube|youtube-nocookie|player\.vimeo)\.com/i,
		nextLink: /(next|weiter|continue|>([^\|]|$)|([^\|]|$))/i,
		prevLink: /(prev|earl|old|new|<|)/i,
		whitespace: /^\s*$/,
		hasContent: /\S$/,
	},

	DIV_TO_P_ELEMS: ["A", "BLOCKQUOTE", "DL", "DIV", "IMG", "OL", "P", "PRE", "TABLE", "UL", "SELECT"],

	ALTER_TO_DIV_EXCEPTIONS: ["DIV", "ARTICLE", "SECTION", "P"],

	PRESENTATIONAL_ATTRIBUTES: ["align", "background", "bgcolor", "border", "cellpadding", "cellspacing", "frame", "hspace", "rules", "style", "valign", "vspace"],

	DEPRECATED_SIZE_ATTRIBUTE_ELEMS: ["TABLE", "TH", "TD", "HR", "PRE"],

	// These are the classes that readability sets itself.
	CLASSES_TO_PRESERVE: ["readability-styled", "page"],

	/**
	 * Run any post-process modifications to article content as necessary.
	 *
	 * @param Element
	 * @return void
	**/
	_postProcessContent: function (articleContent) {
		// Readability cannot open relative uris so we convert them to absolute uris.
		this._fixRelativeUris(articleContent);

		// Remove classes.
		this._cleanClasses(articleContent);
	},

	/**
	 * Iterates over a NodeList, calls `filterFn` for each node and removes node
	 * if function returned `true`.
	 *
	 * If function is not passed, removes all the nodes in node list.
	 *
	 * @param NodeList nodeList The nodes to operate on
	 * @param Function filterFn the function to use as a filter
	 * @return void
	 */
	_removeNodes: function (nodeList, filterFn) {
		for (var i = nodeList.length - 1; i >= 0; i--) {
			var node = nodeList[i];
			var parentNode = node.parentNode;
			if (parentNode) {
				if (!filterFn || filterFn.call(this, node, i, nodeList)) {
					parentNode.removeChild(node);
				}
			}
		}
	},

	/**
	 * Iterates over a NodeList, and calls _setNodeTag for each node.
	 *
	 * @param NodeList nodeList The nodes to operate on
	 * @param String newTagName the new tag name to use
	 * @return void
	 */
	_replaceNodeTags: function (nodeList, newTagName) {
		for (var i = nodeList.length - 1; i >= 0; i--) {
			var node = nodeList[i];
			this._setNodeTag(node, newTagName);
		}
	},

	/**
	 * Iterate over a NodeList, which doesn't natively fully implement the Array
	 * interface.
	 *
	 * For convenience, the current object context is applied to the provided
	 * iterate function.
	 *
	 * @param  NodeList nodeList The NodeList.
	 * @param  Function fn       The iterate function.
	 * @return void
	 */
	_forEachNode: function (nodeList, fn) {
		Array.prototype.forEach.call(nodeList, fn, this);
	},

	/**
	 * Iterate over a NodeList, return true if any of the provided iterate
	 * function calls returns true, false otherwise.
	 *
	 * For convenience, the current object context is applied to the
	 * provided iterate function.
	 *
	 * @param  NodeList nodeList The NodeList.
	 * @param  Function fn       The iterate function.
	 * @return Boolean
	 */
	_someNode: function (nodeList, fn) {
		return Array.prototype.some.call(nodeList, fn, this);
	},

	/**
	 * Concat all nodelists passed as arguments.
	 *
	 * @return ...NodeList
	 * @return Array
	 */
	_concatNodeLists: function () {
		var slice = Array.prototype.slice;
		var args = slice.call(arguments);
		var nodeLists = args.map(function (list) {
			return slice.call(list);
		});
		return Array.prototype.concat.apply([], nodeLists);
	},

	_getAllNodesWithTag: function (node, tagNames) {
		if (node.querySelectorAll) {
			return node.querySelectorAll(tagNames.join(','));
		}
		return [].concat.apply([], tagNames.map(function (tag) {
			var collection = node.getElementsByTagName(tag);
			return Array.isArray(collection) ? collection : Array.from(collection);
		}));
	},

	/**
	 * Removes the class="" attribute from every element in the given
	 * subtree, except those that match CLASSES_TO_PRESERVE and
	 * the classesToPreserve array from the options object.
	 *
	 * @param Element
	 * @return void
	 */
	_cleanClasses: function (node) {
		var classesToPreserve = this._classesToPreserve;
		var className = (node.getAttribute("class") || "")
			.split(/\s+/)
			.filter(function (cls) {
				return classesToPreserve.indexOf(cls) != -1;
			})
			.join(" ");

		if (className) {
			node.setAttribute("class", className);
		} else {
			node.removeAttribute("class");
		}

		for (node = node.firstElementChild; node; node = node.nextElementSibling) {
			this._cleanClasses(node);
		}
	},

	/**
	 * Converts each <a> and <img> uri in the given element to an absolute URI,
	 * ignoring #ref URIs.
	 *
	 * @param Element
	 * @return void
	 */
	_fixRelativeUris: function (articleContent) {
		var baseURI = this._doc.baseURI;
		var documentURI = this._doc.documentURI;
		function toAbsoluteURI(uri) {
			// Leave hash links alone if the base URI matches the document URI:
			if (baseURI == documentURI && uri.charAt(0) == "#") {
				return uri;
			}
			// Otherwise, resolve against base URI:
			try {
				return new URL(uri, baseURI).href;
			} catch (ex) {
				// Something went wrong, just return the original:
			}
			return uri;
		}

		var links = articleContent.getElementsByTagName("a");
		this._forEachNode(links, function (link) {
			var href = link.getAttribute("href");
			if (href) {
				// Replace links with javascript: URIs with text content, since
				// they won't work after scripts have been removed from the page.
				if (href.indexOf("javascript:") === 0) {
					var text = this._doc.createTextNode(link.textContent);
					link.parentNode.replaceChild(text, link);
				} else {
					link.setAttribute("href", toAbsoluteURI(href));
				}
			}
		});

		var imgs = articleContent.getElementsByTagName("img");
		this._forEachNode(imgs, function (img) {
			var src = img.getAttribute("src");
			if (src) {
				img.setAttribute("src", toAbsoluteURI(src));
			}
		});
	},

	/**
	 * Get the article title as an H1.
	 *
	 * @return void
	 **/
	_getArticleTitle: function () {
		var doc = this._doc;
		var curTitle = "";
		var origTitle = "";

		try {
			curTitle = origTitle = doc.title;

			// If they had an element with id "title" in their HTML
			if (typeof curTitle !== "string")
				curTitle = origTitle = this._getInnerText(doc.getElementsByTagName('title')[0]);
		} catch (e) {/* ignore exceptions setting the title. */ }

		var titleHadHierarchicalSeparators = false;
		function wordCount(str) {
			return str.split(/\s+/).length;
		}

		// If there's a separator in the title, first remove the final part
		if ((/ [\|\-\\\/>] /).test(curTitle)) {
			titleHadHierarchicalSeparators = / [\\\/>] /.test(curTitle);
			curTitle = origTitle.replace(/(.*)[\|\-\\\/>] .*/gi, '$1');

			// If the resulting title is too short (3 words or fewer), remove
			// the first part instead:
			if (wordCount(curTitle) < 3)
				curTitle = origTitle.replace(/[^\|\-\\\/>]*[\|\-\\\/>](.*)/gi, '$1');
		} else if (curTitle.indexOf(': ') !== -1) {
			// Check if we have an heading containing this exact string, so we
			// could assume it's the full title.
			var headings = this._concatNodeLists(
				doc.getElementsByTagName('h1'),
				doc.getElementsByTagName('h2')
			);
			var match = this._someNode(headings, function (heading) {
				return heading.textContent === curTitle;
			});

			// If we don't, let's extract the title out of the original title string.
			if (!match) {
				curTitle = origTitle.substring(origTitle.lastIndexOf(':') + 1);

				// If the title is now too short, try the first colon instead:
				if (wordCount(curTitle) < 3) {
					curTitle = origTitle.substring(origTitle.indexOf(':') + 1);
					// But if we have too many words before the colon there's something weird
					// with the titles and the H tags so let's just use the original title instead
				} else if (wordCount(origTitle.substr(0, origTitle.indexOf(':'))) > 5) {
					curTitle = origTitle;
				}
			}
		} else if (curTitle.length > 150 || curTitle.length < 15) {
			var hOnes = doc.getElementsByTagName('h1');

			if (hOnes.length === 1)
				curTitle = this._getInnerText(hOnes[0]);
		}

		curTitle = curTitle.trim();
		// If we now have 4 words or fewer as our title, and either no
		// 'hierarchical' separators (\, /, > or ) were found in the original
		// title or we decreased the number of words by more than 1 word, use
		// the original title.
		var curTitleWordCount = wordCount(curTitle);
		if (curTitleWordCount <= 4 &&
			(!titleHadHierarchicalSeparators ||
				curTitleWordCount != wordCount(origTitle.replace(/[\|\-\\\/>]+/g, "")) - 1)) {
			curTitle = origTitle;
		}

		return curTitle;
	},

	/**
	 * Prepare the HTML document for readability to scrape it.
	 * This includes things like stripping javascript, CSS, and handling terrible markup.
	 *
	 * @return void
	 **/
	_prepDocument: function () {
		var doc = this._doc;

		// Remove all style tags in head
		this._removeNodes(doc.getElementsByTagName("style"));

		if (doc.body) {
			this._replaceBrs(doc.body);
		}

		this._replaceNodeTags(doc.getElementsByTagName("font"), "SPAN");
	},

	/**
	 * Finds the next element, starting from the given node, and ignoring
	 * whitespace in between. If the given node is an element, the same node is
	 * returned.
	 */
	_nextElement: function (node) {
		var next = node;
		while (next
			&& (next.nodeType != this.ELEMENT_NODE)
			&& this.REGEXPS.whitespace.test(next.textContent)) {
			next = next.nextSibling;
		}
		return next;
	},

	/**
	 * Replaces 2 or more successive <br> elements with a single <p>.
	 * Whitespace between <br> elements are ignored. For example:
	 *   <div>foo<br>bar<br> <br><br>abc</div>
	 * will become:
	 *   <div>foo<br>bar<p>abc</p></div>
	 */
	_replaceBrs: function (elem) {
		this._forEachNode(this._getAllNodesWithTag(elem, ["br"]), function (br) {
			var next = br.nextSibling;

			// Whether 2 or more <br> elements have been found and replaced with a
			// <p> block.
			var replaced = false;

			// If we find a <br> chain, remove the <br>s until we hit another element
			// or non-whitespace. This leaves behind the first <br> in the chain
			// (which will be replaced with a <p> later).
			while ((next = this._nextElement(next)) && (next.tagName == "BR")) {
				replaced = true;
				var brSibling = next.nextSibling;
				next.parentNode.removeChild(next);
				next = brSibling;
			}

			// If we removed a <br> chain, replace the remaining <br> with a <p>. Add
			// all sibling nodes as children of the <p> until we hit another <br>
			// chain.
			if (replaced) {
				var p = this._doc.createElement("p");
				br.parentNode.replaceChild(p, br);

				next = p.nextSibling;
				while (next) {
					// If we've hit another <br><br>, we're done adding children to this <p>.
					if (next.tagName == "BR") {
						var nextElem = this._nextElement(next.nextSibling);
						if (nextElem && nextElem.tagName == "BR")
							break;
					}

					// Otherwise, make this node a child of the new <p>.
					var sibling = next.nextSibling;
					p.appendChild(next);
					next = sibling;
				}
			}
		});
	},

	_setNodeTag: function (node, tag) {
		this.log("_setNodeTag", node, tag);
		if (node.__JSDOMParser__) {
			node.localName = tag.toLowerCase();
			node.tagName = tag.toUpperCase();
			return node;
		}

		var replacement = node.ownerDocument.createElement(tag);
		while (node.firstChild) {
			replacement.appendChild(node.firstChild);
		}
		node.parentNode.replaceChild(replacement, node);
		if (node.readability)
			replacement.readability = node.readability;

		for (var i = 0; i < node.attributes.length; i++) {
			replacement.setAttribute(node.attributes[i].name, node.attributes[i].value);
		}
		return replacement;
	},

	/**
	 * Prepare the article node for display. Clean out any inline styles,
	 * iframes, forms, strip extraneous <p> tags, etc.
	 *
	 * @param Element
	 * @return void
	 **/
	_prepArticle: function (articleContent) {
		this._cleanStyles(articleContent);

		// Check for data tables before we continue, to avoid removing items in
		// those tables, which will often be isolated even though they're
		// visually linked to other content-ful elements (text, images, etc.).
		this._markDataTables(articleContent);

		// Clean out junk from the article content
		this._cleanConditionally(articleContent, "form");
		this._cleanConditionally(articleContent, "fieldset");
		this._clean(articleContent, "object");
		this._clean(articleContent, "embed");
		this._clean(articleContent, "h1");
		this._clean(articleContent, "footer");
		this._clean(articleContent, "link");
		this._clean(articleContent, "aside");

		// Clean out elements have "share" in their id/class combinations from final top candidates,
		// which means we don't remove the top candidates even they have "share".
		this._forEachNode(articleContent.children, function (topCandidate) {
			this._cleanMatchedNodes(topCandidate, /share/);
		});

		// If there is only one h2 and its text content substantially equals article title,
		// they are probably using it as a header and not a subheader,
		// so remove it since we already extract the title separately.
		var h2 = articleContent.getElementsByTagName('h2');
		if (h2.length === 1) {
			var lengthSimilarRate = (h2[0].textContent.length - this._articleTitle.length) / this._articleTitle.length;
			if (Math.abs(lengthSimilarRate) < 0.5) {
				var titlesMatch = false;
				if (lengthSimilarRate > 0) {
					titlesMatch = h2[0].textContent.includes(this._articleTitle);
				} else {
					titlesMatch = this._articleTitle.includes(h2[0].textContent);
				}
				if (titlesMatch) {
					this._clean(articleContent, "h2");
				}
			}
		}

		this._clean(articleContent, "iframe");
		this._clean(articleContent, "input");
		this._clean(articleContent, "textarea");
		this._clean(articleContent, "select");
		this._clean(articleContent, "button");
		this._cleanHeaders(articleContent);

		// Do these last as the previous stuff may have removed junk
		// that will affect these
		this._cleanConditionally(articleContent, "table");
		this._cleanConditionally(articleContent, "ul");
		this._cleanConditionally(articleContent, "div");

		// Remove extra paragraphs
		this._removeNodes(articleContent.getElementsByTagName('p'), function (paragraph) {
			var imgCount = paragraph.getElementsByTagName('img').length;
			var embedCount = paragraph.getElementsByTagName('embed').length;
			var objectCount = paragraph.getElementsByTagName('object').length;
			// At this point, nasty iframes have been removed, only remain embedded video ones.
			var iframeCount = paragraph.getElementsByTagName('iframe').length;
			var totalCount = imgCount + embedCount + objectCount + iframeCount;

			return totalCount === 0 && !this._getInnerText(paragraph, false);
		});

		this._forEachNode(this._getAllNodesWithTag(articleContent, ["br"]), function (br) {
			var next = this._nextElement(br.nextSibling);
			if (next && next.tagName == "P")
				br.parentNode.removeChild(br);
		});
	},

	/**
	 * Initialize a node with the readability object. Also checks the
	 * className/id for special names to add to its score.
	 *
	 * @param Element
	 * @return void
	**/
	_initializeNode: function (node) {
		node.readability = { "contentScore": 0 };

		switch (node.tagName) {
			case 'DIV':
				node.readability.contentScore += 5;
				break;

			case 'PRE':
			case 'TD':
			case 'BLOCKQUOTE':
				node.readability.contentScore += 3;
				break;

			case 'ADDRESS':
			case 'OL':
			case 'UL':
			case 'DL':
			case 'DD':
			case 'DT':
			case 'LI':
			case 'FORM':
				node.readability.contentScore -= 3;
				break;

			case 'H1':
			case 'H2':
			case 'H3':
			case 'H4':
			case 'H5':
			case 'H6':
			case 'TH':
				node.readability.contentScore -= 5;
				break;
		}

		node.readability.contentScore += this._getClassWeight(node);
	},

	_removeAndGetNext: function (node) {
		var nextNode = this._getNextNode(node, true);
		node.parentNode.removeChild(node);
		return nextNode;
	},

	/**
	 * Traverse the DOM from node to node, starting at the node passed in.
	 * Pass true for the second parameter to indicate this node itself
	 * (and its kids) are going away, and we want the next node over.
	 *
	 * Calling this in a loop will traverse the DOM depth-first.
	 */
	_getNextNode: function (node, ignoreSelfAndKids) {
		// First check for kids if those aren't being ignored
		if (!ignoreSelfAndKids && node.firstElementChild) {
			return node.firstElementChild;
		}
		// Then for siblings...
		if (node.nextElementSibling) {
			return node.nextElementSibling;
		}
		// And finally, move up the parent chain *and* find a sibling
		// (because this is depth-first traversal, we will have already
		// seen the parent nodes themselves).
		do {
			node = node.parentNode;
		} while (node && !node.nextElementSibling);
		return node && node.nextElementSibling;
	},

	/**
	 * Like _getNextNode, but for DOM implementations with no
	 * firstElementChild/nextElementSibling functionality...
	 */
	_getNextNodeNoElementProperties: function (node, ignoreSelfAndKids) {
		function nextSiblingEl(n) {
			do {
				n = n.nextSibling;
			} while (n && n.nodeType !== n.ELEMENT_NODE);
			return n;
		}
		// First check for kids if those aren't being ignored
		if (!ignoreSelfAndKids && node.children[0]) {
			return node.children[0];
		}
		// Then for siblings...
		var next = nextSiblingEl(node);
		if (next) {
			return next;
		}
		// And finally, move up the parent chain *and* find a sibling
		// (because this is depth-first traversal, we will have already
		// seen the parent nodes themselves).
		do {
			node = node.parentNode;
			if (node)
				next = nextSiblingEl(node);
		} while (node && !next);
		return node && next;
	},

	_checkByline: function (node, matchString) {
		if (this._articleByline) {
			return false;
		}

		if (node.getAttribute !== undefined) {
			var rel = node.getAttribute("rel");
		}

		if ((rel === "author" || this.REGEXPS.byline.test(matchString)) && this._isValidByline(node.textContent)) {
			this._articleByline = node.textContent.trim();
			return true;
		}

		return false;
	},

	_getNodeAncestors: function (node, maxDepth) {
		maxDepth = maxDepth || 0;
		var i = 0, ancestors = [];
		while (node.parentNode) {
			ancestors.push(node.parentNode);
			if (maxDepth && ++i === maxDepth)
				break;
			node = node.parentNode;
		}
		return ancestors;
	},

	/***
	 * grabArticle - Using a variety of metrics (content score, classname, element types), find the content that is
	 *         most likely to be the stuff a user wants to read. Then return it wrapped up in a div.
	 *
	 * @param page a document to run upon. Needs to be a full document, complete with body.
	 * @return Element
	**/
	_grabArticle: function (page) {
		this.log("**** grabArticle ****");
		var doc = this._doc;
		var isPaging = (page !== null ? true : false);
		page = page ? page : this._doc.body;

		// We can't grab an article if we don't have a page!
		if (!page) {
			this.log("No body found in document. Abort.");
			return null;
		}

		var pageCacheHtml = page.innerHTML;

		while (true) {
			var stripUnlikelyCandidates = this._flagIsActive(this.FLAG_STRIP_UNLIKELYS);

			// First, node prepping. Trash nodes that look cruddy (like ones with the
			// class name "comment", etc), and turn divs into P tags where they have been
			// used inappropriately (as in, where they contain no other block level elements.)
			var elementsToScore = [];
			var node = this._doc.documentElement;

			while (node) {
				var matchString = node.className + " " + node.id;

				// Check to see if this node is a byline, and remove it if it is.
				if (this._checkByline(node, matchString)) {
					node = this._removeAndGetNext(node);
					continue;
				}

				// Remove unlikely candidates
				if (stripUnlikelyCandidates) {
					if (this.REGEXPS.unlikelyCandidates.test(matchString) &&
						!this.REGEXPS.okMaybeItsACandidate.test(matchString) &&
						node.tagName !== "BODY" &&
						node.tagName !== "A") {
						this.log("Removing unlikely candidate - " + matchString);
						node = this._removeAndGetNext(node);
						continue;
					}
				}

				// Remove DIV, SECTION, and HEADER nodes without any content(e.g. text, image, video, or iframe).
				if ((node.tagName === "DIV" || node.tagName === "SECTION" || node.tagName === "HEADER" ||
					node.tagName === "H1" || node.tagName === "H2" || node.tagName === "H3" ||
					node.tagName === "H4" || node.tagName === "H5" || node.tagName === "H6") &&
					this._isElementWithoutContent(node)) {
					node = this._removeAndGetNext(node);
					continue;
				}

				if (this.DEFAULT_TAGS_TO_SCORE.indexOf(node.tagName) !== -1) {
					elementsToScore.push(node);
				}

				// Turn all divs that don't have children block level elements into p's
				if (node.tagName === "DIV") {
					// Sites like http://mobile.slate.com encloses each paragraph with a DIV
					// element. DIVs with only a P element inside and no text content can be
					// safely converted into plain P elements to avoid confusing the scoring
					// algorithm with DIVs with are, in practice, paragraphs.
					if (this._hasSinglePInsideElement(node)) {
						var newNode = node.children[0];
						node.parentNode.replaceChild(newNode, node);
						node = newNode;
						elementsToScore.push(node);
					} else if (!this._hasChildBlockElement(node)) {
						node = this._setNodeTag(node, "P");
						elementsToScore.push(node);
					} else {
						// EXPERIMENTAL
						this._forEachNode(node.childNodes, function (childNode) {
							if (childNode.nodeType === this.TEXT_NODE && childNode.textContent.trim().length > 0) {
								var p = doc.createElement('p');
								p.textContent = childNode.textContent;
								p.style.display = 'inline';
								p.className = 'readability-styled';
								node.replaceChild(p, childNode);
							}
						});
					}
				}
				node = this._getNextNode(node);
			}

			/**
			 * Loop through all paragraphs, and assign a score to them based on how content-y they look.
			 * Then add their score to their parent node.
			 *
			 * A score is determined by things like number of commas, class names, etc. Maybe eventually link density.
			**/
			var candidates = [];
			this._forEachNode(elementsToScore, function (elementToScore) {
				if (!elementToScore.parentNode || typeof (elementToScore.parentNode.tagName) === 'undefined')
					return;

				// If this paragraph is less than 25 characters, don't even count it.
				var innerText = this._getInnerText(elementToScore);
				if (innerText.length < 25)
					return;

				// Exclude nodes with no ancestor.
				var ancestors = this._getNodeAncestors(elementToScore, 3);
				if (ancestors.length === 0)
					return;

				var contentScore = 0;

				// Add a point for the paragraph itself as a base.
				contentScore += 1;

				// Add points for any commas within this paragraph.
				contentScore += innerText.split(',').length;

				// For every 100 characters in this paragraph, add another point. Up to 3 points.
				contentScore += Math.min(Math.floor(innerText.length / 100), 3);

				// Initialize and score ancestors.
				this._forEachNode(ancestors, function (ancestor, level) {
					if (!ancestor.tagName)
						return;

					if (typeof (ancestor.readability) === 'undefined') {
						this._initializeNode(ancestor);
						candidates.push(ancestor);
					}

					// Node score divider:
					// - parent:             1 (no division)
					// - grandparent:        2
					// - great grandparent+: ancestor level * 3
					if (level === 0)
						var scoreDivider = 1;
					else if (level === 1)
						scoreDivider = 2;
					else
						scoreDivider = level * 3;
					ancestor.readability.contentScore += contentScore / scoreDivider;
				});
			});

			// After we've calculated scores, loop through all of the possible
			// candidate nodes we found and find the one with the highest score.
			var topCandidates = [];
			for (var c = 0, cl = candidates.length; c < cl; c += 1) {
				var candidate = candidates[c];

				// Scale the final candidates score based on link density. Good content
				// should have a relatively small link density (5% or less) and be mostly
				// unaffected by this operation.
				var candidateScore = candidate.readability.contentScore * (1 - this._getLinkDensity(candidate));
				candidate.readability.contentScore = candidateScore;

				this.log('Candidate:', candidate, "with score " + candidateScore);

				for (var t = 0; t < this._nbTopCandidates; t++) {
					var aTopCandidate = topCandidates[t];

					if (!aTopCandidate || candidateScore > aTopCandidate.readability.contentScore) {
						topCandidates.splice(t, 0, candidate);
						if (topCandidates.length > this._nbTopCandidates)
							topCandidates.pop();
						break;
					}
				}
			}

			var topCandidate = topCandidates[0] || null;
			var neededToCreateTopCandidate = false;
			var parentOfTopCandidate;

			// If we still have no top candidate, just use the body as a last resort.
			// We also have to copy the body node so it is something we can modify.
			if (topCandidate === null || topCandidate.tagName === "BODY") {
				// Move all of the page's children into topCandidate
				topCandidate = doc.createElement("DIV");
				neededToCreateTopCandidate = true;
				// Move everything (not just elements, also text nodes etc.) into the container
				// so we even include text directly in the body:
				var kids = page.childNodes;
				while (kids.length) {
					this.log("Moving child out:", kids[0]);
					topCandidate.appendChild(kids[0]);
				}

				page.appendChild(topCandidate);

				this._initializeNode(topCandidate);
			} else if (topCandidate) {
				// Find a better top candidate node if it contains (at least three) nodes which belong to `topCandidates` array
				// and whose scores are quite closed with current `topCandidate` node.
				var alternativeCandidateAncestors = [];
				for (var i = 1; i < topCandidates.length; i++) {
					if (topCandidates[i].readability.contentScore / topCandidate.readability.contentScore >= 0.75) {
						alternativeCandidateAncestors.push(this._getNodeAncestors(topCandidates[i]));
					}
				}
				var MINIMUM_TOPCANDIDATES = 3;
				if (alternativeCandidateAncestors.length >= MINIMUM_TOPCANDIDATES) {
					parentOfTopCandidate = topCandidate.parentNode;
					while (parentOfTopCandidate.tagName !== "BODY") {
						var listsContainingThisAncestor = 0;
						for (var ancestorIndex = 0; ancestorIndex < alternativeCandidateAncestors.length && listsContainingThisAncestor < MINIMUM_TOPCANDIDATES; ancestorIndex++) {
							listsContainingThisAncestor += Number(alternativeCandidateAncestors[ancestorIndex].includes(parentOfTopCandidate));
						}
						if (listsContainingThisAncestor >= MINIMUM_TOPCANDIDATES) {
							topCandidate = parentOfTopCandidate;
							break;
						}
						parentOfTopCandidate = parentOfTopCandidate.parentNode;
					}
				}
				if (!topCandidate.readability) {
					this._initializeNode(topCandidate);
				}

				// Because of our bonus system, parents of candidates might have scores
				// themselves. They get half of the node. There won't be nodes with higher
				// scores than our topCandidate, but if we see the score going *up* in the first
				// few steps up the tree, that's a decent sign that there might be more content
				// lurking in other places that we want to unify in. The sibling stuff
				// below does some of that - but only if we've looked high enough up the DOM
				// tree.
				parentOfTopCandidate = topCandidate.parentNode;
				var lastScore = topCandidate.readability.contentScore;
				// The scores shouldn't get too low.
				var scoreThreshold = lastScore / 3;
				while (parentOfTopCandidate.tagName !== "BODY") {
					if (!parentOfTopCandidate.readability) {
						parentOfTopCandidate = parentOfTopCandidate.parentNode;
						continue;
					}
					var parentScore = parentOfTopCandidate.readability.contentScore;
					if (parentScore < scoreThreshold)
						break;
					if (parentScore > lastScore) {
						// Alright! We found a better parent to use.
						topCandidate = parentOfTopCandidate;
						break;
					}
					lastScore = parentOfTopCandidate.readability.contentScore;
					parentOfTopCandidate = parentOfTopCandidate.parentNode;
				}

				// If the top candidate is the only child, use parent instead. This will help sibling
				// joining logic when adjacent content is actually located in parent's sibling node.
				parentOfTopCandidate = topCandidate.parentNode;
				while (parentOfTopCandidate.tagName != "BODY" && parentOfTopCandidate.children.length == 1) {
					topCandidate = parentOfTopCandidate;
					parentOfTopCandidate = topCandidate.parentNode;
				}
				if (!topCandidate.readability) {
					this._initializeNode(topCandidate);
				}
			}

			// Now that we have the top candidate, look through its siblings for content
			// that might also be related. Things like preambles, content split by ads
			// that we removed, etc.
			var articleContent = doc.createElement("DIV");
			if (isPaging)
				articleContent.id = "readability-content";

			var siblingScoreThreshold = Math.max(10, topCandidate.readability.contentScore * 0.2);
			// Keep potential top candidate's parent node to try to get text direction of it later.
			parentOfTopCandidate = topCandidate.parentNode;
			var siblings = parentOfTopCandidate.children;

			for (var s = 0, sl = siblings.length; s < sl; s++) {
				var sibling = siblings[s];
				var append = false;

				this.log("Looking at sibling node:", sibling, sibling.readability ? ("with score " + sibling.readability.contentScore) : '');
				this.log("Sibling has score", sibling.readability ? sibling.readability.contentScore : 'Unknown');

				if (sibling === topCandidate) {
					append = true;
				} else {
					var contentBonus = 0;

					// Give a bonus if sibling nodes and top candidates have the example same classname
					if (sibling.className === topCandidate.className && topCandidate.className !== "")
						contentBonus += topCandidate.readability.contentScore * 0.2;

					if (sibling.readability &&
						((sibling.readability.contentScore + contentBonus) >= siblingScoreThreshold)) {
						append = true;
					} else if (sibling.nodeName === "P") {
						var linkDensity = this._getLinkDensity(sibling);
						var nodeContent = this._getInnerText(sibling);
						var nodeLength = nodeContent.length;

						if (nodeLength > 80 && linkDensity < 0.25) {
							append = true;
						} else if (nodeLength < 80 && nodeLength > 0 && linkDensity === 0 &&
							nodeContent.search(/\.( |$)/) !== -1) {
							append = true;
						}
					}
				}

				if (append) {
					this.log("Appending node:", sibling);

					if (this.ALTER_TO_DIV_EXCEPTIONS.indexOf(sibling.nodeName) === -1) {
						// We have a node that isn't a common block level element, like a form or td tag.
						// Turn it into a div so it doesn't get filtered out later by accident.
						this.log("Altering sibling:", sibling, 'to div.');

						sibling = this._setNodeTag(sibling, "DIV");
					}

					articleContent.appendChild(sibling);
					// siblings is a reference to the children array, and
					// sibling is removed from the array when we call appendChild().
					// As a result, we must revisit this index since the nodes
					// have been shifted.
					s -= 1;
					sl -= 1;
				}
			}

			if (this._debug)
				this.log("Article content pre-prep: " + articleContent.innerHTML);
			// So we have all of the content that we need. Now we clean it up for presentation.
			this._prepArticle(articleContent);
			if (this._debug)
				this.log("Article content post-prep: " + articleContent.innerHTML);

			if (neededToCreateTopCandidate) {
				// We already created a fake div thing, and there wouldn't have been any siblings left
				// for the previous loop, so there's no point trying to create a new div, and then
				// move all the children over. Just assign IDs and class names here. No need to append
				// because that already happened anyway.
				topCandidate.id = "readability-page-1";
				topCandidate.className = "page";
			} else {
				var div = doc.createElement("DIV");
				div.id = "readability-page-1";
				div.className = "page";
				var children = articleContent.childNodes;
				while (children.length) {
					div.appendChild(children[0]);
				}
				articleContent.appendChild(div);
			}

			if (this._debug)
				this.log("Article content after paging: " + articleContent.innerHTML);

			var parseSuccessful = true;

			// Now that we've gone through the full algorithm, check to see if
			// we got any meaningful content. If we didn't, we may need to re-run
			// grabArticle with different flags set. This gives us a higher likelihood of
			// finding the content, and the sieve approach gives us a higher likelihood of
			// finding the -right- content.
			var textLength = this._getInnerText(articleContent, true).length;
			if (textLength < this._charThreshold) {
				parseSuccessful = false;
				page.innerHTML = pageCacheHtml;

				if (this._flagIsActive(this.FLAG_STRIP_UNLIKELYS)) {
					this._removeFlag(this.FLAG_STRIP_UNLIKELYS);
					this._attempts.push({ articleContent: articleContent, textLength: textLength });
				} else if (this._flagIsActive(this.FLAG_WEIGHT_CLASSES)) {
					this._removeFlag(this.FLAG_WEIGHT_CLASSES);
					this._attempts.push({ articleContent: articleContent, textLength: textLength });
				} else if (this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY)) {
					this._removeFlag(this.FLAG_CLEAN_CONDITIONALLY);
					this._attempts.push({ articleContent: articleContent, textLength: textLength });
				} else {
					this._attempts.push({ articleContent: articleContent, textLength: textLength });
					// No luck after removing flags, just return the longest text we found during the different loops
					this._attempts.sort(function (a, b) {
						return a.textLength < b.textLength;
					});

					// But first check if we actually have something
					if (!this._attempts[0].textLength) {
						return null;
					}

					articleContent = this._attempts[0].articleContent;
					parseSuccessful = true;
				}
			}

			if (parseSuccessful) {
				// Find out text direction from ancestors of final top candidate.
				var ancestors = [parentOfTopCandidate, topCandidate].concat(this._getNodeAncestors(parentOfTopCandidate));
				this._someNode(ancestors, function (ancestor) {
					if (!ancestor.tagName)
						return false;
					var articleDir = ancestor.getAttribute("dir");
					if (articleDir) {
						this._articleDir = articleDir;
						return true;
					}
					return false;
				});
				return articleContent;
			}
		}
	},

	/**
	 * Check whether the input string could be a byline.
	 * This verifies that the input is a string, and that the length
	 * is less than 100 chars.
	 *
	 * @param possibleByline {string} - a string to check whether its a byline.
	 * @return Boolean - whether the input string is a byline.
	 */
	_isValidByline: function (byline) {
		if (typeof byline == 'string' || byline instanceof String) {
			byline = byline.trim();
			return (byline.length > 0) && (byline.length < 100);
		}
		return false;
	},

	/**
	 * Attempts to get excerpt and byline metadata for the article.
	 *
	 * @return Object with optional "excerpt" and "byline" properties
	 */
	_getArticleMetadata: function () {
		var metadata = {};
		var values = {};
		var metaElements = this._doc.getElementsByTagName("meta");

		// Match "description", or Twitter's "twitter:description" (Cards)
		// in name attribute.
		var namePattern = /^\s*((twitter)\s*:\s*)?(description|title)\s*$/gi;

		// Match Facebook's Open Graph title & description properties.
		var propertyPattern = /^\s*og\s*:\s*(description|title)\s*$/gi;

		// Find description tags.
		this._forEachNode(metaElements, function (element) {
			var elementName = element.getAttribute("name");
			var elementProperty = element.getAttribute("property");

			if ([elementName, elementProperty].indexOf("author") !== -1) {
				metadata.byline = element.getAttribute("content");
				return;
			}

			var name = null;
			if (namePattern.test(elementName)) {
				name = elementName;
			} else if (propertyPattern.test(elementProperty)) {
				name = elementProperty;
			}

			if (name) {
				var content = element.getAttribute("content");
				if (content) {
					// Convert to lowercase and remove any whitespace
					// so we can match below.
					name = name.toLowerCase().replace(/\s/g, '');
					values[name] = content.trim();
				}
			}
		});

		if ("description" in values) {
			metadata.excerpt = values["description"];
		} else if ("og:description" in values) {
			// Use facebook open graph description.
			metadata.excerpt = values["og:description"];
		} else if ("twitter:description" in values) {
			// Use twitter cards description.
			metadata.excerpt = values["twitter:description"];
		}

		metadata.title = this._getArticleTitle();
		if (!metadata.title) {
			if ("og:title" in values) {
				// Use facebook open graph title.
				metadata.title = values["og:title"];
			} else if ("twitter:title" in values) {
				// Use twitter cards title.
				metadata.title = values["twitter:title"];
			}
		}

		return metadata;
	},

	/**
	 * Removes script tags from the document.
	 *
	 * @param Element
	**/
	_removeScripts: function (doc) {
		this._removeNodes(doc.getElementsByTagName('script'), function (scriptNode) {
			scriptNode.nodeValue = "";
			scriptNode.removeAttribute('src');
			return true;
		});
		this._removeNodes(doc.getElementsByTagName('noscript'));
	},

	/**
	 * Check if this node has only whitespace and a single P element
	 * Returns false if the DIV node contains non-empty text nodes
	 * or if it contains no P or more than 1 element.
	 *
	 * @param Element
	**/
	_hasSinglePInsideElement: function (element) {
		// There should be exactly 1 element child which is a P:
		if (element.children.length != 1 || element.children[0].tagName !== "P") {
			return false;
		}

		// And there should be no text nodes with real content
		return !this._someNode(element.childNodes, function (node) {
			return node.nodeType === this.TEXT_NODE &&
				this.REGEXPS.hasContent.test(node.textContent);
		});
	},

	_isElementWithoutContent: function (node) {
		return node.nodeType === this.ELEMENT_NODE &&
			node.textContent.trim().length == 0 &&
			(node.children.length == 0 ||
				node.children.length == node.getElementsByTagName("br").length + node.getElementsByTagName("hr").length);
	},

	/**
	 * Determine whether element has any children block level elements.
	 *
	 * @param Element
	 */
	_hasChildBlockElement: function (element) {
		return this._someNode(element.childNodes, function (node) {
			return this.DIV_TO_P_ELEMS.indexOf(node.tagName) !== -1 ||
				this._hasChildBlockElement(node);
		});
	},

	/**
	 * Get the inner text of a node - cross browser compatibly.
	 * This also strips out any excess whitespace to be found.
	 *
	 * @param Element
	 * @param Boolean normalizeSpaces (default: true)
	 * @return string
	**/
	_getInnerText: function (e, normalizeSpaces) {
		normalizeSpaces = (typeof normalizeSpaces === 'undefined') ? true : normalizeSpaces;
		var textContent = e.textContent.trim();

		if (normalizeSpaces) {
			return textContent.replace(this.REGEXPS.normalize, " ");
		}
		return textContent;
	},

	/**
	 * Get the number of times a string s appears in the node e.
	 *
	 * @param Element
	 * @param string - what to split on. Default is ","
	 * @return number (integer)
	**/
	_getCharCount: function (e, s) {
		s = s || ",";
		return this._getInnerText(e).split(s).length - 1;
	},

	/**
	 * Remove the style attribute on every e and under.
	 * TODO: Test if getElementsByTagName(*) is faster.
	 *
	 * @param Element
	 * @return void
	**/
	_cleanStyles: function (e) {
		if (!e || e.tagName.toLowerCase() === 'svg')
			return;

		if (e.className !== 'readability-styled') {
			// Remove `style` and deprecated presentational attributes
			for (var i = 0; i < this.PRESENTATIONAL_ATTRIBUTES.length; i++) {
				e.removeAttribute(this.PRESENTATIONAL_ATTRIBUTES[i]);
			}

			if (this.DEPRECATED_SIZE_ATTRIBUTE_ELEMS.indexOf(e.tagName) !== -1) {
				e.removeAttribute('width');
				e.removeAttribute('height');
			}
		}

		var cur = e.firstElementChild;
		while (cur !== null) {
			this._cleanStyles(cur);
			cur = cur.nextElementSibling;
		}
	},

	/**
	 * Get the density of links as a percentage of the content
	 * This is the amount of text that is inside a link divided by the total text in the node.
	 *
	 * @param Element
	 * @return number (float)
	**/
	_getLinkDensity: function (element) {
		var textLength = this._getInnerText(element).length;
		if (textLength === 0)
			return 0;

		var linkLength = 0;

		// XXX implement _reduceNodeList?
		this._forEachNode(element.getElementsByTagName("a"), function (linkNode) {
			linkLength += this._getInnerText(linkNode).length;
		});

		return linkLength / textLength;
	},

	/**
	 * Get an elements class/id weight. Uses regular expressions to tell if this
	 * element looks good or bad.
	 *
	 * @param Element
	 * @return number (Integer)
	**/
	_getClassWeight: function (e) {
		if (!this._flagIsActive(this.FLAG_WEIGHT_CLASSES))
			return 0;

		var weight = 0;

		// Look for a special classname
		if (typeof (e.className) === 'string' && e.className !== '') {
			if (this.REGEXPS.negative.test(e.className))
				weight -= 25;

			if (this.REGEXPS.positive.test(e.className))
				weight += 25;
		}

		// Look for a special ID
		if (typeof (e.id) === 'string' && e.id !== '') {
			if (this.REGEXPS.negative.test(e.id))
				weight -= 25;

			if (this.REGEXPS.positive.test(e.id))
				weight += 25;
		}

		return weight;
	},

	/**
	 * Clean a node of all elements of type "tag".
	 * (Unless it's a youtube/vimeo video. People love movies.)
	 *
	 * @param Element
	 * @param string tag to clean
	 * @return void
	 **/
	_clean: function (e, tag) {
		var isEmbed = ["object", "embed", "iframe"].indexOf(tag) !== -1;

		this._removeNodes(e.getElementsByTagName(tag), function (element) {
			// Allow youtube and vimeo videos through as people usually want to see those.
			if (isEmbed) {
				var attributeValues = [].map.call(element.attributes, function (attr) {
					return attr.value;
				}).join("|");

				// First, check the elements attributes to see if any of them contain youtube or vimeo
				if (this.REGEXPS.videos.test(attributeValues))
					return false;

				// Then check the elements inside this element for the same.
				if (this.REGEXPS.videos.test(element.innerHTML))
					return false;
			}

			return true;
		});
	},

	/**
	 * Check if a given node has one of its ancestor tag name matching the
	 * provided one.
	 * @param  HTMLElement node
	 * @param  String      tagName
	 * @param  Number      maxDepth
	 * @param  Function    filterFn a filter to invoke to determine whether this node 'counts'
	 * @return Boolean
	 */
	_hasAncestorTag: function (node, tagName, maxDepth, filterFn) {
		maxDepth = maxDepth || 3;
		tagName = tagName.toUpperCase();
		var depth = 0;
		while (node.parentNode) {
			if (maxDepth > 0 && depth > maxDepth)
				return false;
			if (node.parentNode.tagName === tagName && (!filterFn || filterFn(node.parentNode)))
				return true;
			node = node.parentNode;
			depth++;
		}
		return false;
	},

	/**
	 * Return an object indicating how many rows and columns this table has.
	 */
	_getRowAndColumnCount: function (table) {
		var rows = 0;
		var columns = 0;
		var trs = table.getElementsByTagName("tr");
		for (var i = 0; i < trs.length; i++) {
			var rowspan = trs[i].getAttribute("rowspan") || 0;
			if (rowspan) {
				rowspan = parseInt(rowspan, 10);
			}
			rows += (rowspan || 1);

			// Now look for column-related info
			var columnsInThisRow = 0;
			var cells = trs[i].getElementsByTagName("td");
			for (var j = 0; j < cells.length; j++) {
				var colspan = cells[j].getAttribute("colspan") || 0;
				if (colspan) {
					colspan = parseInt(colspan, 10);
				}
				columnsInThisRow += (colspan || 1);
			}
			columns = Math.max(columns, columnsInThisRow);
		}
		return { rows: rows, columns: columns };
	},

	/**
	 * Look for 'data' (as opposed to 'layout') tables, for which we use
	 * similar checks as
	 * https://dxr.mozilla.org/mozilla-central/rev/71224049c0b52ab190564d3ea0eab089a159a4cf/accessible/html/HTMLTableAccessible.cpp#920
	 */
	_markDataTables: function (root) {
		var tables = root.getElementsByTagName("table");
		for (var i = 0; i < tables.length; i++) {
			var table = tables[i];
			var role = table.getAttribute("role");
			if (role == "presentation") {
				table._readabilityDataTable = false;
				continue;
			}
			var datatable = table.getAttribute("datatable");
			if (datatable == "0") {
				table._readabilityDataTable = false;
				continue;
			}
			var summary = table.getAttribute("summary");
			if (summary) {
				table._readabilityDataTable = true;
				continue;
			}

			var caption = table.getElementsByTagName("caption")[0];
			if (caption && caption.childNodes.length > 0) {
				table._readabilityDataTable = true;
				continue;
			}

			// If the table has a descendant with any of these tags, consider a data table:
			var dataTableDescendants = ["col", "colgroup", "tfoot", "thead", "th"];
			var descendantExists = function (tag) {
				return !!table.getElementsByTagName(tag)[0];
			};
			if (dataTableDescendants.some(descendantExists)) {
				this.log("Data table because found data-y descendant");
				table._readabilityDataTable = true;
				continue;
			}

			// Nested tables indicate a layout table:
			if (table.getElementsByTagName("table")[0]) {
				table._readabilityDataTable = false;
				continue;
			}

			var sizeInfo = this._getRowAndColumnCount(table);
			if (sizeInfo.rows >= 10 || sizeInfo.columns > 4) {
				table._readabilityDataTable = true;
				continue;
			}
			// Now just go by size entirely:
			table._readabilityDataTable = sizeInfo.rows * sizeInfo.columns > 10;
		}
	},

	/**
	 * Clean an element of all tags of type "tag" if they look fishy.
	 * "Fishy" is an algorithm based on content length, classnames, link density, number of images & embeds, etc.
	 *
	 * @return void
	 **/
	_cleanConditionally: function (e, tag) {
		if (!this._flagIsActive(this.FLAG_CLEAN_CONDITIONALLY))
			return;

		var isList = tag === "ul" || tag === "ol";

		// Gather counts for other typical elements embedded within.
		// Traverse backwards so we can remove nodes at the same time
		// without effecting the traversal.
		//
		// TODO: Consider taking into account original contentScore here.
		this._removeNodes(e.getElementsByTagName(tag), function (node) {
			// First check if we're in a data table, in which case don't remove us.
			var isDataTable = function (t) {
				return t._readabilityDataTable;
			};

			if (this._hasAncestorTag(node, "table", -1, isDataTable)) {
				return false;
			}

			var weight = this._getClassWeight(node);
			var contentScore = 0;

			this.log("Cleaning Conditionally", node);

			if (weight + contentScore < 0) {
				return true;
			}

			if (this._getCharCount(node, ',') < 10) {
				// If there are not very many commas, and the number of
				// non-paragraph elements is more than paragraphs or other
				// ominous signs, remove the element.
				var p = node.getElementsByTagName("p").length;
				var img = node.getElementsByTagName("img").length;
				var li = node.getElementsByTagName("li").length - 100;
				var input = node.getElementsByTagName("input").length;

				var embedCount = 0;
				var embeds = node.getElementsByTagName("embed");
				for (var ei = 0, il = embeds.length; ei < il; ei += 1) {
					if (!this.REGEXPS.videos.test(embeds[ei].src))
						embedCount += 1;
				}

				var linkDensity = this._getLinkDensity(node);
				var contentLength = this._getInnerText(node).length;

				var haveToRemove =
					(img > 1 && p / img < 0.5 && !this._hasAncestorTag(node, "figure")) ||
					(!isList && li > p) ||
					(input > Math.floor(p / 3)) ||
					(!isList && contentLength < 25 && (img === 0 || img > 2) && !this._hasAncestorTag(node, "figure")) ||
					(!isList && weight < 25 && linkDensity > 0.2) ||
					(weight >= 25 && linkDensity > 0.5) ||
					((embedCount === 1 && contentLength < 75) || embedCount > 1);
				return haveToRemove;
			}
			return false;
		});
	},

	/**
	 * Clean out elements whose id/class combinations match specific string.
	 *
	 * @param Element
	 * @param RegExp match id/class combination.
	 * @return void
	 **/
	_cleanMatchedNodes: function (e, regex) {
		var endOfSearchMarkerNode = this._getNextNode(e, true);
		var next = this._getNextNode(e);
		while (next && next != endOfSearchMarkerNode) {
			if (regex.test(next.className + " " + next.id)) {
				next = this._removeAndGetNext(next);
			} else {
				next = this._getNextNode(next);
			}
		}
	},

	/**
	 * Clean out spurious headers from an Element. Checks things like classnames and link density.
	 *
	 * @param Element
	 * @return void
	**/
	_cleanHeaders: function (e) {
		for (var headerIndex = 1; headerIndex < 3; headerIndex += 1) {
			this._removeNodes(e.getElementsByTagName('h' + headerIndex), function (header) {
				return this._getClassWeight(header) < 0;
			});
		}
	},

	_flagIsActive: function (flag) {
		return (this._flags & flag) > 0;
	},

	_removeFlag: function (flag) {
		this._flags = this._flags & ~flag;
	},

	/**
	 * Decides whether or not the document is reader-able without parsing the whole thing.
	 *
	 * @return boolean Whether or not we suspect parse() will suceeed at returning an article object.
	 */
	isProbablyReaderable: function (helperIsVisible) {
		var nodes = this._getAllNodesWithTag(this._doc, ["p", "pre"]);

		// Get <div> nodes which have <br> node(s) and append them into the `nodes` variable.
		// Some articles' DOM structures might look like
		// <div>
		//   Sentences<br>
		//   <br>
		//   Sentences<br>
		// </div>
		var brNodes = this._getAllNodesWithTag(this._doc, ["div > br"]);
		if (brNodes.length) {
			var set = new Set();
			[].forEach.call(brNodes, function (node) {
				set.add(node.parentNode);
			});
			nodes = [].concat.apply(Array.from(set), nodes);
		}

		// FIXME we should have a fallback for helperIsVisible, but this is
		// problematic because of jsdom's elem.style handling - see
		// https://github.com/mozilla/readability/pull/186 for context.

		var score = 0;
		// This is a little cheeky, we use the accumulator 'score' to decide what to return from
		// this callback:
		return this._someNode(nodes, function (node) {
			if (helperIsVisible && !helperIsVisible(node))
				return false;
			var matchString = node.className + " " + node.id;

			if (this.REGEXPS.unlikelyCandidates.test(matchString) &&
				!this.REGEXPS.okMaybeItsACandidate.test(matchString)) {
				return false;
			}

			if (node.matches && node.matches("li p")) {
				return false;
			}

			var textContentLength = node.textContent.trim().length;
			if (textContentLength < 140) {
				return false;
			}

			score += Math.sqrt(textContentLength - 140);

			if (score > 20) {
				return true;
			}
			return false;
		});
	},

	/**
	 * Runs readability.
	 *
	 * Workflow:
	 *  1. Prep the document by removing script tags, css, etc.
	 *  2. Build readability's DOM tree.
	 *  3. Grab the article content from the current dom tree.
	 *  4. Replace the current DOM tree with the new one.
	 *  5. Read peacefully.
	 *
	 * @return void
	 **/
	parse: function () {
		// Avoid parsing too large documents, as per configuration option
		if (this._maxElemsToParse > 0) {
			var numTags = this._doc.getElementsByTagName("*").length;
			if (numTags > this._maxElemsToParse) {
				throw new Error("Aborting parsing document; " + numTags + " elements found");
			}
		}

		if (typeof this._doc.documentElement.firstElementChild === "undefined") {
			this._getNextNode = this._getNextNodeNoElementProperties;
		}
		// Remove script tags from the document.
		this._removeScripts(this._doc);

		this._prepDocument();

		var metadata = this._getArticleMetadata();
		this._articleTitle = metadata.title;

		var articleContent = this._grabArticle();
		if (!articleContent)
			return null;

		this.log("Grabbed: " + articleContent.innerHTML);

		this._postProcessContent(articleContent);

		// If we haven't found an excerpt in the article's metadata, use the article's
		// first paragraph as the excerpt. This is used for displaying a preview of
		// the article's content.
		if (!metadata.excerpt) {
			var paragraphs = articleContent.getElementsByTagName("p");
			if (paragraphs.length > 0) {
				metadata.excerpt = paragraphs[0].textContent.trim();
			}
		}

		var textContent = articleContent.textContent;
		return {
			title: this._articleTitle,
			byline: metadata.byline || this._articleByline,
			dir: this._articleDir,
			content: articleContent.innerHTML,
			textContent: textContent,
			length: textContent.length,
			excerpt: metadata.excerpt,
		};
	}
};

if (typeof module === "object") {
	module.exports = Readability;
}
window.pfMetaData = {
	self: this,
	data: {
		title: '',
		description: '',
		image: '',
		author: '',
		feed: '',
		canonical: '',
		keywords: [],
		openGraph: {
			title: '',
			type: 'article'
		},
		twitter: {
			title: '',
		},
		jsonLD: {},
	},
	checkForProp: function (val) {
		if (val === undefined || val === null || val === false || val.length < 1) {
			return false;
		} else {
			return true;
		}
	},
	init: function () {
		var self = window.pfMetaData;
		self.data.title = document.title;
		self.processMeta();
		self.processLinks();
		self.processJSONLD();
		self.assureMajorMetadataFilled();
		var aTag = document.createElement('input');
		aTag.setAttribute('id', 'pfnt-pfMetaData');
		aTag.setAttribute('style', 'display:none;');
		console.log();
		aTag.value = JSON.stringify(self.data);
		document.getElementsByTagName('body')[0].appendChild(aTag);
	},
	assureMajorMetadataFilled: function () {
		var self = window.pfMetaData;
		if (false === self.cascadeMetaValues('title')) {
			if (self.checkForProp(self.data.jsonLD.headline)) {
				self.data.title = self.jsonLD.headline;
			}
		}
		if (false === self.cascadeMetaValues('description')) {
			if (self.checkForProp(self.data.jsonLD.description)) {
				self.data.description = self.jsonLD.description;
			}
		}
		if (false === self.cascadeMetaValues('author')) {
			if (self.checkForProp(self.data.jsonLD.author) && self.checkForProp(self.data.jsonLD.author.name)) {
				self.data.author = self.data.jsonLD.author.name;
			}
		}
		if (false === self.cascadeMetaValues('image')) {
			if (self.checkForProp(self.data.jsonLD.image) && self.checkForProp(self.data.jsonLD.image[0])) {
				self.data.image = self.jsonLD.image[0];
			}
		}
		if (false === self.checkForProp('canonical')) {
			if (self.checkForProp(self.data.openGraph.url)) {
				self.data.canonical = self.data.openGraph.url;
			} else if (self.checkForProp(self.data.jsonLD.mainEntityOfPage) && self.checkForProp(self.data.jsonLD.mainEntityOfPage['@id'])) {
				self.data.canonical = self.data.jsonLD.mainEntityOfPage['@id'];
			}
		}
		if (false !== self.checkForProp(self.data.openGraph.section)) {
			self.data.keywords.push(self.data.openGraph.section);
		}
		if (false !== self.checkForProp(self.data.openGraph.tag)) {
			self.data.keywords = self.data.keywords.concat(self.data.openGraph.tag);
		}
		var metaKeywords = document.querySelector('meta[name="keywords"]');
		if (null !== metaKeywords && undefined !== metaKeywords) {
			var keywordsString = metaKeywords.content;
			self.data.keywords = self.data.keywords.concat(keywordsString.split(','));
		}
	},
	cascadeMetaValues: function (prop) {
		var self = window.pfMetaData;
		if (!self.checkForProp(self.data[prop])) {
			if (!self.checkForProp(self.data.openGraph[prop])) {
				if (!self.checkForProp(self.data.twitter[prop])) {
					return false;
				} else {
					self.data[prop] = self.data.twitter[prop];
				}
			} else {
				self.data[prop] = self.data.openGraph[prop];
			}
		}
		return true;
	},
	processOpenGraphTag: function (element, type) {
		var self = window.pfMetaData;
		var firstTriple = type.length;
		firstTriple += 1;
		var ogTags = document.querySelectorAll('meta[property="' + element + '"]');
		if (ogTags.length > 0) {
			console.log(ogTags);
			if (element === 'og:type' && ogTags[0] && ogTags[0].length && ogTags[0].hasOwnPropery('content')) {
				self.data.openGraph[element.substring(firstTriple)] = ogTags[0].content;
			} else if (1 === ogTags.length) {
				self.data.openGraph[element.substring(firstTriple)] = ogTags[0].content;
			} else if (ogTags.length > 1) {
				var elementName = element.substring(firstTriple);
				self.data.openGraph[elementName] = [];
				ogTags.forEach(function (element) {
					self.data.openGraph[elementName].push(element.content);
				});
			}
		}
	},
	processMeta: function () {
		var self = window.pfMetaData;
		var metas = document.getElementsByTagName('meta');
		var defaultMetas = [
			'author',
			'description'
		];
		defaultMetas.forEach(function (element) {
			var self = window.pfMetaData;
			if (undefined !== metas[element]) {
				self.data[element] = metas[element].content;
			}
		});
		var twitterMetas = [
			'twitter:card',
			'twitter:creator',
			'twitter:description',
			'twitter:image',
			'twitter:site',
			'twitter:title'
		];
		twitterMetas.forEach(function (element) {
			var self = window.pfMetaData;
			if (undefined !== metas[element]) {
				window.pfMetaData.data.twitter[element.substring(8)] = metas[element].content;
			}
		});
		var ogPropertyMetas = [
			'og:title',
			'og:site_name',
			'og:description',
			'og:url',
			'og:locale',
			'og:type',
			'og:image'
		];
		ogPropertyMetas.forEach(function (element) {
			var self = window.pfMetaData;
			self.processOpenGraphTag(element, 'og');
		});
		var ogPropertyTypeMetas = [
			self.data.openGraph.type + ':published_time',
			self.data.openGraph.type + ':author',
			self.data.openGraph.type + ':publisher',
			self.data.openGraph.type + ':section',
			self.data.openGraph.type + ':tag',
			self.data.openGraph.type + ':image',
		];
		ogPropertyTypeMetas.forEach(function (element) {
			var self = window.pfMetaData;
			self.processOpenGraphTag(element, self.data.openGraph.type);
		});
	},
	processLink: function (selector) {
		var aTag = document.head.querySelector('link[' + selector + ']');
		if (null !== aTag) {
			return aTag.href;
		} else {
			return false;
		}
	},
	processLinks: function () {
		var self = window.pfMetaData;
		// var links = document.getElementsByTagName('link');
		self.data.canonical = self.processLink('rel="canonical"');
		self.data.feed = self.processLink('type="application/rss+xml"');
	},
	processJSONLD: function () {
		var self = window.pfMetaData;
		var JSONLDTag = document.head.querySelector('script[type="application/ld+json"]');
		if (null !== JSONLDTag) {
			try {
				self.data.jsonLD = JSON.parse(JSONLDTag.innerHTML);
			} catch (e) {
				console.log('JSON LD Broken');
			}
		}
	}
};
window.pfMetaData.init();
(function () {
	console.log('Nominate This Setup');

	if (null !== document.getElementById('pressforward-nt')) {
		window.pfnt_deactivate();
	}
	//Coming in:
	//var d=document,
	//w=window,
	//e=w.getSelection,
	//k=d.getSelection,
	//x=d.selection,
	//s=(e?e():(k)?k():(x?x.createRange().text:0)),
	//l=d.location,
	//e=encodeURIComponent,
	//

	//https://docs.ckeditor.com/ckeditor5/latest/builds/guides/quick-start.html#classic-editor

	window.pfnt = {};
	window.pfnt.windows = {};
	window.pfnt.windows.links = [];
	window.pfnt.windows.scripts = [];
	window.pfnt.windows.styleBlocks = [];
	window.pfnt.styles = {};
	window.pfnt.tools = {};
	window.pfReadability = {};
	window.pfnt.key = window.ku;
	window.pfnt.selection = window.getSelection().toString();
	window.pfnt.submitObject = {
		post_title: false,
		item_link: window.location.href,
		pf_source_link: window.location.origin,
		// post_type: false,
		post_status: false,
		content: false, //post_content
		tax_input: false,
		item_feat_img: false,
		item_author: false,
		post_tags: false,
		user_key: window.ku,
		photo_src: [],
		photo_description: [],
		action: 'post',
	};

	function generateTag(el, id, className, style) {
		var aTag = document.createElement(el);
		aTag.setAttribute('id', id);
		aTag.setAttribute('class', className);
		aTag.setAttribute('style', style);
		return aTag;
	}

	function textareaBuilder(contents) {
		var editorContainer = generateTag('div', 'wp-nomthis-editor-container', 'wp-editor-container', '');

		// var toolbar = generateTag('div', 'qt_nomthis_toolbar', 'quicktags-toolbar', '');

		// editorContainer.appendChild(toolbar);
		// editorContainer.appendChild(nomTextArea);
		window.pfnt.windows.editorContainer = editorContainer;
		return editorContainer;
	}

	function linkElement(linkUrl, rel, type) {
		//var linkUrl = 'https://cdn.quilljs.com/1.0.0/quill.snow.css';
		var linkE = document.createElement('link');
		linkE.setAttribute('rel', rel);
		linkE.setAttribute('href', linkUrl);
		linkE.setAttribute('type', type);
		// linkE.setAttribute('media', 'all');
		var headTag = document.getElementsByTagName('head')[0];
		window.pfnt.windows.links.push(linkE);
		headTag.prepend(linkE);
		return linkE;
	}

	function scriptElement(scriptUrl) {
		//var linkUrl = 'https://cdn.quilljs.com/1.0.0/quill.snow.css';
		var scriptE = document.createElement('script');
		//scriptE.setAttribute('src', scriptUrl);
		scriptE.src = scriptUrl;
		window.pfnt.windows.scripts.push(scriptE);
		return scriptE;
	}

	function stylesAndScripts() {
		var headTag = document.getElementsByTagName('head')[0];
		var styleE = document.createElement('style');
		styleE.innerHTML = '#wp-nomthis-editor-container { width: 100%; }' + " \n " +
			'#pressforward-nt { color: #111; }' + " \n " +
			'#pressforward-nt h1, #pressforward-nt h2, #pressforward-nt h3, #pressforward-nt h5 { color: #111; }' + " \n " +
			'#pressforward-nt input { color: #111; margin-bottom: 1px; }' + " \n " +
			'.pressforward-nt__inputfield { width:100%; display:block; color: #111; }' + " \n " +
			'#pressforward-nt input { color: #111; background-color: white; cursor: text; padding: 1px; border-width: 2px; border-style: inset; }' + " \n " +
			'.pressforward-nt__inner-container { height: 100%; }' + " \n " +
			'.meta-box { background-color: whitesmoke; }' + " \n " +
			'.meta-box img { max-height: 100%; }' + " \n " +
			'.meta-box h5 { font-family: "Arial Black", Gadget, sans-serif; border: 3px #bbbbbb inset; padding: 3px; height: 17%; margin-bottom: 2%; box-sizing: border-box; min-height: 33px; font-size: 14px; }' + " \n " +
			'.pressforward-nt__li-category-select-item { margin-bottom: 6px; padding: 0; line-height: 22px; word-wrap: break-word; }' + " \n " +
			'.pressforward-nt__li-category-select-item li { font-size: 16px; max-height: 25px; color: black; border-bottom-color: rgb(180, 185, 190); border-bottom-width: 1px; } ' + " \n " +
			'#pressforward-nt__right ul, #pressforward-nt__right li { list-style-type: none; }' + " \n " +
			'#pressforward-nt__right ul .select-inner-text { margin-left: 4px; vertical-align: middle; }' + " \n " +
			'#pressforward-nt__preview-category-container__inner input[type=checkbox], #pressforward-nt__preview-category-container__inner label { cursor: pointer; }' + " \n " +
			window.pfSiteData.fontFace;
		window.pfnt.windows.styleBlocks.push(styleE);
		headTag.prepend(styleE);
		// headTag.prepend(linkElement('https://github.com/tinymce/tinymce-dist/raw/master/skins/lightgray/fonts/tinymce.ttf', ));
		// <link href=' http://fonts.googleapis.com/css?family=Droid+Sans' rel='stylesheet' type='text/css'>
		// linkElement('https://cdn.quilljs.com/1.0.0/quill.snow.css')
	}

	function ctrlBar() {
		var ctrlContainer = document.createElement('div');
		ctrlContainer.setAttribute('id', 'wp-nomthis-wrap');
		ctrlContainer.setAttribute('class', 'wp-core-ui wp-editor-wrap tmce-active');


		var toolDiv = document.createElement('div');
		toolDiv.setAttribute('id', 'wp-nomthis-editor-tools');
		toolDiv.setAttribute('class', 'wp-editor-tools hide-if-no-js');
		var toolDivInner = document.createElement('div');
		toolDiv.setAttribute('class', 'wp-editor-tabs');
		var visualButton = document.createElement('button');
		visualButton.setAttribute('id', 'nomthis-tmce');
		visualButton.setAttribute('class', 'wp-switch-editor switch-tmce');
		visualButton.setAttribute('data-wp-editor-id', 'nomthis');
		visualButton.innerHTML = 'Visual';
		var textButton = document.createElement('button');
		textButton.setAttribute('id', 'nomthis-tmce');
		textButton.setAttribute('class', 'wp-switch-editor switch-tmce');
		textButton.setAttribute('data-wp-editor-id', 'nomthis');
		textButton.innerHTML = 'Text';

		toolDivInner.appendChild(visualButton);
		toolDivInner.appendChild(textButton);
		toolDiv.appendChild(toolDivInner);

		ctrlContainer.appendChild(toolDiv);

		return ctrlContainer;
	}

	function buildCategoryElement(container, value) {
		return new Promise(function (resolve, reject) {
			var liContainer = window.document.getElementById('category-' + value.id);
			if (liContainer === null) {
				liContainer = generateTag('li', 'category-' + value.id, 'pressforward-nt__li-category-select-item');
			} else {
				resolve(true);
				return true;
			}
			var labelBox = generateTag('label', '', 'selectit', '');
			var inputCheck = generateTag('input', 'in-category-' + value.id, 'pressforward-nt__li-select-item__input', '')
			inputCheck.setAttribute('value', value.id);
			inputCheck.setAttribute('type', 'checkbox');
			inputCheck.setAttribute('name', 'post_category[]');

			var catName = generateTag('span', '', 'select-inner-text', '');
			catName.innerHTML = value.name;

			labelBox.appendChild(inputCheck);
			labelBox.appendChild(catName);
			liContainer.prepend(labelBox);

			if (0 !== value.parent) {
				// window.document.querySelector('#pressforward-nt__preview-tags-container input').value;
				var parentContainer = window.document.querySelector('#category-' + value.parent + ' ul');
				var parentLI = window.document.getElementById('category-' + value.parent)
				if (null === parentContainer && null === parentLI) {
					var xhr = new XMLHttpRequest();
					xhr.open('GET', value._links.up[0].href, true);
					//xhr.setRequestHeader("Content-type", "application/json");
					//xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
					xhr.addEventListener('load', function (event) {
						if (xhr.readyState == 4 && xhr.status == 200) {
							var json = JSON.parse(xhr.responseText);

							// var totalCats = xhr.getResponseHeader('X-WP-Total');
							// var catPages = xhr.getResponseHeader('X-WP-TotalPages');
							console.log('cat parent:', json);
							resolve(new Promise(function (resolveNext, reject) {
								buildCategoryElement(container, json).then(function () {
									parentLI = window.document.getElementById('category-' + value.parent);
									var ulContainer = generateTag('ul', '', 'select-inner-text', '');
									parentLI.appendChild(ulContainer)
									parentContainer = ulContainer;
									parentContainer.appendChild(liContainer);
									resolveNext(true);
								});
							}));
						} else {
							console.log(json);
							alert('Cat retrieve failed');
							resolve(false);
						}
					});
					// var data = JSON.stringify(window.pfnt.submitObject);
					// var data = urlEncodedData;
					xhr.send();

				} else if (null === parentContainer) {
					var ulContainer = generateTag('ul', '', 'select-inner-text', '');
					parentLI.appendChild(ulContainer)
					parentContainer = ulContainer;
					parentContainer.appendChild(liContainer);
					resolve(true);
				} else {
					parentContainer.appendChild(liContainer);
					resolve(true);
				}
			} else {
				container.appendChild(liContainer);
				resolve(true);
			}
		});
	}

	function categoriesElement(container, p) {
		var pageString = '';
		if (p) {
			pageString = '?page=' + p;
		} else {
			p = 1;
		}
		var promise1 = new Promise(function (resolve, reject) {
			var xhr = new XMLHttpRequest();
			xhr.open('GET', window.pfSiteData.categories_endpoint + pageString, true);
			//xhr.setRequestHeader("Content-type", "application/json");
			//xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
			xhr.addEventListener('load', function (event) {
				if (xhr.readyState == 4 && xhr.status == 200) {
					var json = JSON.parse(xhr.responseText);

					var totalCats = xhr.getResponseHeader('X-WP-Total');
					var catPages = xhr.getResponseHeader('X-WP-TotalPages');
					console.log('cat list:', json, totalCats, catPages);
					var c = 0;
					var promiseSet = json.reduce(function (promiseChain, value, index, subjectArray) {
						c++;
						return promiseChain.then(function () { return buildCategoryElement(container, value) });;
						// still hitting race condition here. Solve with reduce a la https://decembersoft.com/posts/promises-in-serial-with-array-reduce/ ?
					}, Promise.resolve([])).then(arrayOfResults => {
						resolve({ totalPages: catPages });
					});
					// Promise.all(promiseSet).then((data) => { resolve({ totalPages: catPages }); });

					// container.appendChild();
				} else {
					console.log(json);
					alert('Cat retrieve failed');
				}
			});
			// var data = JSON.stringify(window.pfnt.submitObject);
			// var data = urlEncodedData;
			xhr.send();
		}).then(function (data) {
			if (p + 1 <= data.totalPages) {
				categoriesElement(container, p + 1);
			}
		});
	}

	function sidebar(container) {
		var imageStyles = 'background-image: url(' + window.pfMetaData.data.image + ');' +
			'width: 100%;' +
			'background-size: contain;' +
			'background-repeat: no-repeat;' +
			'background-position: center;' +
			'background-color: transparent;' +
			'height: 77%;' +
			'display: block;' +
			'box-sizing: border-box;';
		var imageArea = generateTag('div', 'pressforward-nt__preview-image', 'preview-image', imageStyles);
		imageArea.src = window.pfMetaData.data.image;

		var tagStyles = 'width: 80%;' +
			'height: 26px;' +
			'font-size: small;' +
			'margin-left: 10px;';
		var tagContainer = generateTag('div', 'pressforward-nt__preview-tags-container', 'meta-box pressforward-nt-box', 'height:18%; overflow:hidden; display: block;');
		tagContainer.innerHTML = '<h5>Tags</h5><input type="text" value="' + window.pfMetaData.data.keywords.join(', ') + '" style="' + tagStyles + '">';
		// tagContainer.appendChild(imageArea);

		var imageContainer = generateTag('div', 'pressforward-nt__preview-image-container', 'meta-box pressforward-nt-box', 'height:36%; overflow:hidden; display: block;');
		imageContainer.innerHTML = '<h5>Preview Image</h5>';
		imageContainer.appendChild(imageArea);

		var buttonContainer = generateTag('div', 'pressforward-nt__button-container', 'meta-box pressforward-nt-box', 'height:12%; overflow:hidden; display: block;');
		buttonContainer.innerHTML = '<button id="pressforward-nt__submit-button" role="presentation" type="button" tabindex="-1" style="width: 100px; height: 30px; margin: 22px 10px; float: right; font-size: 14px;" onclick="window.pfntSubmit(true)">Submit</button>';
		buttonContainer.innerHTML += '<button id="pressforward-nt__nominate-button" role="presentation" type="button" tabindex="-1" style="width: 100px; height: 30px; margin: 22px 10px; float: right; font-size: 14px;" onclick="window.pfntSubmit(false)">Nominate</button>';
		// buttonContainer.appendChild(imageArea);

		var hiddenContainer = generateTag('input', 'pressforward-nt__input-data', '', 'overflow:hidden; display: none;');
		var hiddenVerifyDataContainer = generateTag('input', 'pressforward-nt__input-verify', '', 'overflow:hidden; display: none;');
		hiddenVerifyDataContainer.value = window.localStorage.getItem('verifyEncoded');

		var categoryContainer = generateTag('div', 'pressforward-nt__preview-category-container', 'meta-box pressforward-nt-box', 'height:34%; overflow:hidden; display: block;');
		categoryContainer.innerHTML = '<h5>Categories</h5>';
		var categoryUl = generateTag('ul', 'pressforward-nt__preview-category-container__inner', 'checkable-list-container', 'margin-left: 5px; height: 83%; width:100%; overflow:scroll; display: block;');
		categoryContainer.appendChild(categoryUl);
		categoriesElement(categoryUl);

		container.appendChild(categoryContainer);
		container.appendChild(hiddenContainer);
		container.appendChild(hiddenVerifyDataContainer);
		container.appendChild(tagContainer);
		container.appendChild(imageContainer);
		container.appendChild(buttonContainer);
	}

	function pfnt_activate() {

		var pf = window.pfnt;
		var windows = window.pfnt.windows;
		var pf_styles = window.pfnt.styles;
		var pf_tools = window.pfnt.tools;
		var documentClone = document.cloneNode(true);
		window.pfReadability.article = new Readability(documentClone).parse();

		windows.mainWindow = generateTag('div', 'pressforward-nt', 'nomthis-wrapper', '');

		windows.innerWindow = generateTag('div', 'pressforward-nt__inner', 'nomthis-inner-wrapper', '');

		windows.titleField = generateTag('input', 'pressforward-nt__inputfield__title', 'pressforward-nt__inputfield', '');
		windows.titleField.setAttribute('type', 'text');
		if (window.pfReadability.article.title <= 1) {
			windows.titleField.setAttribute('value', window.pfMetaData.data.title);
		} else {
			windows.titleField.setAttribute('value', window.pfReadability.article.title);
		}

		windows.bylineField = generateTag('input', 'pressforward-nt__inputfield__byline', 'pressforward-nt__inputfield', '');
		windows.bylineField.setAttribute('type', 'text');
		if (window.pfMetaData && window.pfMetaData.data && window.pfMetaData.data.hasOwnProperty('author')) {
			windows.bylineField.setAttribute('value', window.pfMetaData.data.author);
		} else if (window.pfReadability && window.pfReadability.hasOwnProperty('article') && window.pfReadability.article.hasOwnProperty('byline') && window.pfReadability.article.byline.length <= 1) {
			windows.bylineField.setAttribute('value', window.pfReadability.article.byline);
		}

		pf_styles.mwStyles = 'position: fixed;' +
			'width: 76%;' +
			'height: 550px;' +
			'display: block;' +
			'background: #c7c7c7;' +
			'top: 0;' +
			'left: 12%;' +
			'padding: 1px;' +
			'box-sizing: border-box;' +
			'z-index: 9999990000;';

		pf_styles.iwStyles = 'position: relative;' +
			'width: 100%;' +
			'height: 100%;' +
			'background: white;' +
			'border: #afceaf 3px solid;' +
			'box-sizing: border-box;';

		windows.mainWindow.setAttribute('style', pf_styles.mwStyles);

		windows.innerWindow.setAttribute('style', pf_styles.iwStyles);

		windows.innerLeft = generateTag('div', 'pressforward-nt__left', 'pressforward-nt__inner-container', 'float:left; width:60%');
		windows.innerRight = generateTag('div', 'pressforward-nt__right', 'pressforward-nt__inner-container', 'float:right; width:37%; padding-left: 1%; padding: 0 10px;');

		var articleContent = '';
		if (window.pfnt.selection.length > 2) {
			articleContent = window.pfnt.selection;
		} else {
			articleContent = window.pfReadability.article.content;
		}

		var pfMainWindowAppender = function () { document.getElementsByTagName('body')[0].prepend(window.pfnt.windows.mainWindow); };
		var pfInnerWindowAppender = function () {
			window.pfnt.windows.mainWindow.appendChild(window.pfnt.windows.innerWindow);
			window.pfnt.windows.innerWindow.appendChild(window.pfnt.windows.innerLeft);
			window.pfnt.windows.innerWindow.appendChild(window.pfnt.windows.innerRight);
			window.pfnt.windows.innerLeft.appendChild(window.pfnt.windows.titleField);
			window.pfnt.windows.innerLeft.appendChild(window.pfnt.windows.bylineField);
			window.pfnt.windows.innerLeft.appendChild(textareaBuilder(articleContent));
			sidebar(window.pfnt.windows.innerRight);
		};

		pfMainWindowAppender();
		pfInnerWindowAppender();

		window.initEditor = function () {
			// window.ntEditor = tinymce.init({ selector: '#nominateText', theme: 'simple' });
			var pellEditer = pell.init({
				// <HTMLElement>, required
				element: document.getElementById('wp-nomthis-editor-container'),

				// <Function>, required
				// Use the output html, triggered by element's `oninput` event
				onChange: html => console.log(html),

				// <string>, optional, default = 'div'
				// Instructs the editor which element to inject via the return key
				defaultParagraphSeparator: 'p',

				// <boolean>, optional, default = false
				// Outputs <span style="font-weight: bold;"></span> instead of <b></b>
				styleWithCSS: false,

				// <Array[string | Object]>, string if overwriting, object if customizing/creating
				// action.name<string> (only required if overwriting)
				// action.icon<string> (optional if overwriting, required if custom action)
				// action.title<string> (optional)
				// action.result<Function> (required)
				// Specify the actions you specifically want (in order)
				actions: [
					'bold',
					'italic',
					'underline',
					'strikethrough',
					'heading1',
					'heading2',
					'paragraph',
					'quote',
					'olist',
					'ulist',
					'code',
					'line',
					'link'

				],

				// classes<Array[string]> (optional)
				// Choose your custom class names
				classes: {
					actionbar: 'pell-actionbar',
					button: 'pell-button',
					content: 'nominateText pell-content',
					selected: 'pell-button-selected'
				},
				onChange: html => {
					window.editorData = html
				}
			})

			var articleContent = '';
			if (window.pfnt.selection.length > 2) {
				articleContent = window.pfnt.selection;
			} else {
				articleContent = window.pfReadability.article.content;
			}

			var nomTextArea = document.getElementById('wp-nomthis-editor-container');
			// generateTag('textarea', 'nominateText', 'wp-editor-area', 'height:375px;');
			var nomTextBox = document.getElementsByClassName('nominateText')[0];
			nomTextArea.setAttribute('name', 'post_content');
			nomTextArea.setAttribute('autocomplete', 'off');
			nomTextArea.setAttribute('cols', '40');

			nomTextArea.setAttribute('style', 'height:375px;');
			nomTextBox.setAttribute('id', 'nominateText');
			nomTextBox.classList.add('wp-editor-area');
			nomTextBox.setAttribute('name', 'post_content');
			nomTextBox.setAttribute('style', 'height:375px;');

			pellEditer.content.innerHTML = articleContent;
			window.pfnt.editorObject = pellEditer;
		};

		stylesAndScripts();

	};

	pfnt_activate();

})();

window.pfnt_deactivate = function () {
	function clearInner(node) {
		while (node.hasChildNodes()) {
			clear(node.firstChild);
		}
	}

	function clear(node) {
		while (node.hasChildNodes()) {
			clear(node.firstChild);
		}
		node.parentNode.removeChild(node);
		console.log(node, "cleared!");
	}
	clearInner(window.pfnt.windows.mainWindow);
	window.pfnt.windows.mainWindow.remove();
}

window.pfntSubmitOld = function (publish) {
	console.log('Submitting to PressForward');
	window.pfnt.submitObject.post_title = window.document.getElementById('pressforward-nt__inputfield__title').value;
	window.pfnt.submitObject.item_author = window.document.getElementById('pressforward-nt__inputfield__byline').value;
	window.pfnt.submitObject.content = window.document.getElementById('nominateText').innerHTML;
	window.pfnt.submitObject.item_feat_img = window.pfMetaData.image;
	window.pfnt.submitObject.post_tags = window.document.querySelector('#pressforward-nt__preview-tags-container input').value;
	if (publish) {
		window.pfnt.submitObject.publish = 'Last Step';
		window.pfnt.submitObject.post_status = 'publish';
	}
	var urlEncodedData = "";
	var urlEncodedDataPairs = [];
	Object.keys(window.pfnt.submitObject).forEach((key) => {
		if (window.pfnt.submitObject[key]) {
			if ('string' === typeof window.pfnt.submitObject[key]) {
				var value = window.pfnt.submitObject[key].trim();
			} else {
				var value = window.pfnt.submitObject[key];
			}
			urlEncodedDataPairs.push(encodeURIComponent(key.trim()) + '=' + encodeURIComponent(value));
		}
	});
	urlEncodedData = urlEncodedDataPairs.join('&').replace(/%20/g, '+');
	var xhr = new XMLHttpRequest();
	xhr.open('POST', pfSiteData.submit_endpoint, true);
	//xhr.setRequestHeader("Content-type", "application/json");
	xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
	xhr.addEventListener('load', function (event) {
		if (xhr.readyState == 4 && xhr.status == 200) {
			var json = JSON.parse(xhr.responseText);
			console.log(json);
		} else {
			console.log(json);
			alert('Nomination failed');
		}
	});
	// var data = JSON.stringify(window.pfnt.submitObject);
	var data = urlEncodedData;
	xhr.send(data);
};

//function attachSubmit() {
window.pfntSubmit = function (publish) {
	console.log('On Page Submitting to PressForward');
	window.pfMetaData = JSON.parse(window.document.getElementById('pfnt-pfMetaData').value);
	window.pfnt.submitObject.post_title = window.document.getElementById('pressforward-nt__inputfield__title').value;
	window.pfnt.submitObject.item_author = window.document.getElementById('pressforward-nt__inputfield__byline').value;
	window.pfnt.submitObject.content = window.document.getElementById('nominateText').innerHTML;
	window.pfnt.submitObject.item_feat_img = window.pfMetaData.image;
	window.pfnt.submitObject.post_tags = window.document.querySelector('#pressforward-nt__preview-tags-container input').value;
	window.pfnt.submitObject.post_category = '';
	var categories = window.document.getElementsByClassName('pressforward-nt__li-select-item__input');
	for (let categoryCheckbox of categories) {
		if (true === categoryCheckbox.checked) {
			window.pfnt.submitObject.post_category += categoryCheckbox.value + ',';
		}
	};
	window.pfnt.submitObject.post_category += '';
	if (publish) {
		window.pfnt.submitObject.publish = 'Last Step';
		window.pfnt.submitObject.post_status = 'publish';
	}
	window.pfnt.submitObject.extensionMode = true;
	window.document.getElementById('pressforward-nt__input-data').value = JSON.stringify(window.pfnt.submitObject);
	//chrome.runtime.sendMessage(window.pfnt.extensionID, window.pfnt.submitObject, null, function () { });
};
//}
// attachSubmit();
// console.log('Window.pfntSubmit = ', window.pfntSubmit);

window.initEditor();